[
  {
    "question": "SOLIDのSが表す原則は？",
    "options": [
      "単一責任の原則",
      "安全性の原則",
      "拡張性の原則",
      "簡潔性の原則"
    ],
    "answer": 0,
    "tags": ["design-principles"],
    "explanation": "SRP：1つのクラスに変更理由は1つだけ。"
  },
  {
    "question": "DRY原則の意味は？",
    "options": [
      "同じことを繰り返すな",
      "早く乾かせ",
      "ドキュメントを読め",
      "テストを書け"
    ],
    "answer": 0,
    "tags": ["design-principles"],
    "explanation": "Don't Repeat Yourself：重複を排除。"
  },
  {
    "question": "O(n log n)の代表的ソートは？",
    "options": [
      "マージソート",
      "バブルソート",
      "選択ソート",
      "挿入ソート"
    ],
    "answer": 0,
    "tags": ["data-structures"],
    "explanation": "マージソートは分割統治法により安定してO(n log n)を達成する代表的なソートアルゴリズム。"
  },
  {
    "question": "スタック(Stack)のアクセス方式は？",
    "options": [
      "LIFO",
      "FIFO",
      "ランダムアクセス",
      "優先度順"
    ],
    "answer": 0,
    "tags": ["data-structures"],
    "explanation": "スタックはLast In, First Out方式で、最後に入れた要素を最初に取り出す。"
  },
  {
    "question": "KISS原則の意味は？",
    "options": [
      "シンプルに保て",
      "素早くイテレーション",
      "常にテスト",
      "ペアプロせよ"
    ],
    "answer": 0,
    "tags": ["design-principles"],
    "explanation": "Keep It Simple, Stupid：不要な複雑さを避けシンプルな設計を保つ。"
  },
  {
    "question": "ハッシュテーブルの平均探索計算量は？",
    "options": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n²)"
    ],
    "answer": 0,
    "tags": ["data-structures"],
    "explanation": "ハッシュテーブルは衝突がなければO(1)。"
  },
  {
    "question": "二分探索の前提条件は？",
    "options": [
      "ソート済み",
      "重複なし",
      "数値のみ",
      "固定長"
    ],
    "answer": 0,
    "tags": ["data-structures"],
    "explanation": "二分探索は中央値との比較で範囲を半減するため、データがソート済みであることが前提。"
  },
  {
    "question": "関数型プログラミングで重視される概念は？",
    "options": [
      "副作用のない純粋関数",
      "クラスの継承",
      "グローバル変数活用",
      "ポインタ操作"
    ],
    "answer": 0,
    "tags": ["programming"],
    "explanation": "純粋関数は同じ入力に同じ出力を返す。"
  },
  {
    "question": "Singletonパターンの特徴は？",
    "options": [
      "インスタンスを1つだけ生成",
      "複数IFを統合",
      "オブジェクト複製",
      "処理を並列化"
    ],
    "answer": 0,
    "tags": ["design-patterns"],
    "explanation": "GoFの生成パターンの一つで、クラスのインスタンスがただ1つであることを保証する。"
  },
  {
    "question": "SOLIDのOが表す原則は？",
    "options": [
      "開放閉鎖の原則",
      "最適化の原則",
      "OOP原則",
      "順序の原則"
    ],
    "answer": 0,
    "tags": ["design-principles"],
    "explanation": "OCP：拡張に開き、修正に閉じる。"
  },
  {
    "question": "再帰関数に必要不可欠な要素は？",
    "options": [
      "基底条件",
      "グローバル変数",
      "マルチスレッド",
      "例外処理"
    ],
    "answer": 0,
    "tags": ["programming"],
    "explanation": "基底条件がないと再帰が無限ループになりスタックオーバーフローを引き起こす。"
  },
  {
    "question": "連結リストの先頭挿入の計算量は？",
    "options": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n²)"
    ],
    "answer": 0,
    "tags": ["data-structures"],
    "explanation": "連結リストの先頭挿入はポインタの付け替えのみで完了するためO(1)。"
  },
  {
    "question": "キュー(Queue)のアクセス方式は？",
    "options": [
      "FIFO",
      "LIFO",
      "ランダムアクセス",
      "優先度順"
    ],
    "answer": 0,
    "tags": ["data-structures"],
    "explanation": "キューはFirst In, First Out方式で、最初に入れた要素を最初に取り出す。"
  },
  {
    "question": "ポリモーフィズムの主な利点は？",
    "options": [
      "同じIFで異なる振る舞い",
      "メモリ削減",
      "コンパイル短縮",
      "DB最適化"
    ],
    "answer": 0,
    "tags": ["programming"],
    "explanation": "ポリモーフィズムにより同一インターフェースで異なる実装を呼び分けられ、拡張性が向上する。"
  },
  {
    "question": "バブルソートの最悪計算量は？",
    "options": [
      "O(n²)",
      "O(n)",
      "O(n log n)",
      "O(1)"
    ],
    "answer": 0,
    "tags": ["data-structures"],
    "explanation": "バブルソートは隣接要素を繰り返し比較交換するため、最悪・平均ともにO(n²)。"
  },
  {
    "question": "Observerパターンの用途は？",
    "options": [
      "状態変化を複数に通知",
      "データソート",
      "認証処理",
      "DB接続"
    ],
    "answer": 0,
    "tags": ["design-patterns"],
    "explanation": "GoFの振る舞いパターンの一つで、あるオブジェクトの状態変化を依存する複数のオブジェクトに自動通知する。"
  },
  {
    "question": "ガベージコレクションの役割は？",
    "options": [
      "不要メモリの自動解放",
      "コード最適化",
      "テスト実行",
      "ログ出力"
    ],
    "answer": 0,
    "tags": ["programming"],
    "explanation": "GCは参照されなくなったオブジェクトのメモリを自動で回収し、メモリリークを防ぐ。"
  },
  {
    "question": "木構造のBFSが使うデータ構造は？",
    "options": [
      "キュー",
      "スタック",
      "ハッシュマップ",
      "配列"
    ],
    "answer": 0,
    "tags": ["data-structures"],
    "explanation": "BFS(幅優先探索)はキューを用いて各階層のノードを順に処理する。"
  },
  {
    "question": "クロージャとは？",
    "options": [
      "外部変数を参照する関数",
      "クラスの一種",
      "ループ構文",
      "エラーハンドリング"
    ],
    "answer": 0,
    "tags": ["programming"],
    "explanation": "クロージャは定義時のスコープにある外部変数を捕捉し、関数の実行後も参照し続ける関数。"
  },
  {
    "question": "抽象クラスとIFの違いは？",
    "options": [
      "抽象クラスは実装を持てる",
      "違いはない",
      "IFは継承不可",
      "抽象は多重継承可"
    ],
    "answer": 0,
    "tags": ["programming"],
    "explanation": "抽象クラスはメソッドの実装やフィールドを持てるが、インターフェースは基本的にメソッドの契約のみを定義する。"
  },
  {
    "question": "Big-O記法で定数項や低次項を省略する理由は？",
    "options": [
      "入力サイズ増加時の支配的な傾向を見るため",
      "計算を簡単に見せるため",
      "厳密性が不要だから",
      "メモリ使用量を表すため"
    ],
    "answer": 0,
    "tags": ["data-structures"],
    "explanation": "Big-O記法は入力サイズnが十分大きいときの増加率(漸近的挙動)を示すため、低次項や定数は無視する。"
  },
  {
    "question": "インターフェース分離の原則(ISP)が避けたい状態は？",
    "options": [
      "使わないメソッドへの依存",
      "クラスの継承",
      "関数の分割",
      "自動テストの追加"
    ],
    "answer": 0,
    "tags": ["design-principles"],
    "explanation": "ISPはクライアントが利用しないメソッドに依存させないよう、インターフェースを細かく分離する原則。"
  },
  {
    "question": "リファクタリングの目的として最も適切なのは？",
    "options": [
      "外部仕様を変えず内部品質を高める",
      "機能を必ず追加する",
      "テストを削除する",
      "リリース頻度を下げる"
    ],
    "answer": 0,
    "tags": ["refactoring"],
    "explanation": "リファクタリングは外部から見た振る舞いを変えずに、コードの内部構造を改善する作業。"
  },
  {
    "question": "依存性注入(DI)の利点は？",
    "options": [
      "結合度を下げてテストしやすくする",
      "実行速度を必ず最大化する",
      "例外処理を不要にする",
      "メモリ使用をゼロにする"
    ],
    "answer": 0,
    "tags": ["design-principles", "programming"],
    "explanation": "DIは依存先を外部から注入することで結合度を下げ、モックへの差し替えなどテスト容易性を高める。"
  },
  {
    "question": "イミュータブルな設計の利点として適切なのは？",
    "options": [
      "状態変更バグを減らしやすい",
      "必ずコード量が減る",
      "通信回数がなくなる",
      "UIが自動生成される"
    ],
    "answer": 0,
    "tags": ["programming"],
    "explanation": "イミュータブルなオブジェクトは一度生成すると変更されないため、予期しない状態変更によるバグを防ぎやすい。"
  },
  {
    "question": "循環参照が増えると起きやすい問題は？",
    "options": [
      "変更影響の追跡が難しくなる",
      "テスト速度が必ず向上する",
      "ビルドが不要になる",
      "依存管理が不要になる"
    ],
    "answer": 0,
    "tags": ["design-principles", "code-quality"],
    "explanation": "循環参照があるとモジュール間の依存が双方向になり、変更の影響範囲が把握しにくくなる。"
  },
  {
    "question": "境界値分析が有効な入力は？",
    "options": [
      "上限・下限が定義された値",
      "自由記述の感想文",
      "画像の色味",
      "乱数のみの値"
    ],
    "answer": 0,
    "tags": ["testing"],
    "explanation": "境界値分析は有効範囲の境界(上限・下限付近)にバグが集中しやすいことを利用したテスト技法。"
  },
  {
    "question": "早すぎる最適化を避ける理由は？",
    "options": [
      "可読性と保守性を損なうリスクがあるため",
      "CPU使用率がゼロになるため",
      "設計不要になるため",
      "DBが不要になるため"
    ],
    "answer": 0,
    "tags": ["code-quality"],
    "explanation": "D.クヌースの格言：プロファイルなき最適化は可読性を犠牲にし、保守コストを増大させる。"
  },
  {
    "question": "関心の分離(SoC)の狙いは？",
    "options": [
      "変更理由ごとにコードを分ける",
      "全処理を1ファイルに集約する",
      "命名を短縮する",
      "例外を無視する"
    ],
    "answer": 0,
    "tags": ["design-principles"],
    "explanation": "SoCは異なる関心事を独立したモジュールに分離し、変更の影響範囲を局所化する設計原則。"
  },
  {
    "question": "レイヤードアーキテクチャの利点は？",
    "options": [
      "責務が明確になり変更しやすい",
      "常に最速になる",
      "学習コストがゼロになる",
      "インフラが不要になる"
    ],
    "answer": 0,
    "tags": ["design-principles"],
    "explanation": "層ごとに責務を分離することで各層の変更が他層に波及しにくくなり、保守性が向上する。"
  },
  {
    "question": "コード重複を許容する判断があり得る場面は？",
    "options": [
      "抽象化コストが価値を上回る初期段階",
      "常に全コードで許容",
      "本番障害中のみ恒久化",
      "レビューをしない場合"
    ],
    "answer": 0,
    "tags": ["code-quality", "design-principles"],
    "explanation": "Rule of Three等の考え方では、早すぎる抽象化よりも重複を2回程度は許容し、パターンが明確になってから共通化する。"
  },
  {
    "question": "N+1問題が起きやすい層は？",
    "options": [
      "データアクセス層の反復クエリ",
      "CSSレイアウト",
      "ルーティング定義",
      "型エイリアス定義"
    ],
    "answer": 0,
    "tags": ["programming"],
    "explanation": "N+1問題はORMなどで一覧取得後に関連データを1件ずつ問い合わせることで大量のクエリが発行される問題。"
  },
  {
    "question": "アルゴリズム選択で最初に確認すべきことは？",
    "options": [
      "入力規模と制約条件",
      "開発者の好み",
      "エディタテーマ",
      "コメント量"
    ],
    "answer": 0,
    "tags": ["data-structures"],
    "explanation": "入力規模(n)と制約条件により必要な計算量の上限が決まり、適切なアルゴリズムを選択できる。"
  },
  {
    "question": "可読性の高い関数設計として適切なのは？",
    "options": [
      "短く単一責務で名前が意図を示す",
      "長く多機能で汎用名にする",
      "副作用を増やす",
      "引数を隠す"
    ],
    "answer": 0,
    "tags": ["code-quality"],
    "explanation": "CleanCode：関数は小さく単一の責務を持ち、名前から意図が読み取れることが可読性の鍵。"
  },
  {
    "question": "マジックナンバーを避ける主な理由は？",
    "options": [
      "意味が不明で変更に弱くなるため",
      "実行速度が必ず下がるため",
      "型推論できないため",
      "テスト不能になるため"
    ],
    "answer": 0,
    "tags": ["code-quality"],
    "explanation": "マジックナンバーは意味が不明なリテラル値であり、名前付き定数に置き換えることで意図が明確になり変更にも強くなる。"
  },
  {
    "question": "フェイルファスト設計の考え方は？",
    "options": [
      "異常を早期検知し被害を最小化する",
      "例外を握りつぶす",
      "ログを出さない",
      "検証を後回しにする"
    ],
    "answer": 0,
    "tags": ["code-quality"],
    "explanation": "フェイルファストは異常を検出したら即座に報告・停止し、問題の拡大と原因特定の困難化を防ぐ設計方針。"
  },
  {
    "question": "純粋関数の条件として正しいものは？",
    "options": [
      "同じ入力なら同じ出力で副作用がない",
      "内部状態を毎回更新する",
      "グローバル変数必須",
      "非同期でのみ動く"
    ],
    "answer": 0,
    "tags": ["programming"],
    "explanation": "純粋関数は参照透過性を持ち、同じ引数に対して常に同じ結果を返し外部状態を変更しない。"
  },
  {
    "question": "APIの後方互換性を守る典型手段は？",
    "options": [
      "破壊的変更を避けバージョニングする",
      "常に同時置換する",
      "通知なしで削除する",
      "ドキュメントを省略する"
    ],
    "answer": 0,
    "tags": ["release", "design-principles"],
    "explanation": "セマンティックバージョニング等を活用し、破壊的変更はメジャーバージョンで行うことで後方互換性を維持する。"
  },
  {
    "question": "メモ化(memoization)が有効なケースは？",
    "options": [
      "同じ計算を繰り返し呼ぶ純関数",
      "毎回乱数を返す処理",
      "副作用だらけの処理",
      "I/O待ち専用処理"
    ],
    "answer": 0,
    "tags": ["programming"],
    "explanation": "メモ化は純粋関数の結果をキャッシュし、同一引数の再計算を省くことで計算量を削減する手法。"
  },
  {
    "question": "デッドコードを放置するリスクは？",
    "options": [
      "理解コストと誤変更リスクが増える",
      "バグが必ず減る",
      "レビュー不要になる",
      "容量が必ず減る"
    ],
    "answer": 0,
    "tags": ["code-quality"],
    "explanation": "デッドコードは読み手の認知負荷を増やし、誤って変更・依存してしまうリスクを生む。"
  },
  {
    "question": "設計原則YAGNIの意味は？",
    "options": [
      "今必要ない機能は作らない",
      "将来機能を必ず先に作る",
      "要件を無視する",
      "テストを後回しにする"
    ],
    "answer": 0,
    "tags": ["design-principles"],
    "explanation": "You Aren't Gonna Need It：実際に必要になるまで機能を実装しないことで無駄な複雑さを防ぐ。"
  },
  {
    "question": "技術選定でPoCを行う主目的は？",
    "options": [
      "不確実性とリスクを早期に検証する",
      "正式導入を省略する",
      "全コードを書き直す",
      "見積もりを不要にする"
    ],
    "answer": 0,
    "tags": ["design-principles"],
    "explanation": "PoC(Proof of Concept)は小規模な検証で技術的な不確実性やリスクを早期に明らかにする手法。"
  },
  {
    "question": "依存性逆転の原則(DIP)が推奨する設計は？",
    "options": [
      "上位モジュールが抽象に依存する",
      "下位モジュールが上位に直接依存する",
      "すべてのモジュールが具象クラスに依存する",
      "依存関係を持たない"
    ],
    "answer": 0,
    "tags": ["design-principles"],
    "explanation": "DIPでは上位モジュールも下位モジュールも抽象(インターフェース)に依存すべきとされる。"
  },
  {
    "question": "Compositeパターンの用途は？",
    "options": [
      "個別オブジェクトと集合を同一インターフェースで扱う",
      "オブジェクトの生成を一箇所に集約する",
      "状態遷移を管理する",
      "通信プロトコルを抽象化する"
    ],
    "answer": 0,
    "tags": ["design-patterns"],
    "explanation": "Compositeパターンはツリー構造を構成し、個別要素と複合要素を同じインターフェースで統一的に扱う。"
  },
  {
    "question": "ハッシュテーブルの平均的な探索時間計算量は？",
    "options": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ],
    "answer": 0,
    "tags": ["data-structures"],
    "explanation": "ハッシュテーブルはハッシュ関数により平均O(1)でキーに対応する値を探索できる。"
  },
  {
    "question": "イミュータブルなデータ構造の利点は？",
    "options": [
      "副作用がなく並行処理でも安全",
      "メモリ使用量が常に少ない",
      "パフォーマンスが常に最速",
      "型安全性が不要になる"
    ],
    "answer": 0,
    "tags": ["programming"],
    "explanation": "イミュータブルなデータは変更不可のため副作用が発生せず、スレッドセーフで予測可能なコードになる。"
  },
  {
    "question": "KISS原則が戒めるものは？",
    "options": [
      "不必要な複雑さ",
      "テストの実施",
      "ドキュメントの作成",
      "コードレビュー"
    ],
    "answer": 0,
    "tags": ["design-principles"],
    "explanation": "KISS(Keep It Simple, Stupid)はシンプルさを保ち、不必要に複雑な設計を避けることを推奨する原則。"
  },
  {
    "question": "Builderパターンの主な目的は？",
    "options": [
      "複雑なオブジェクトの構築を段階的に行う",
      "既存オブジェクトのコピーを作成する",
      "オブジェクトの振る舞いを動的に変更する",
      "シングルトンを実現する"
    ],
    "answer": 0,
    "tags": ["design-patterns"],
    "explanation": "Builderパターンは複雑なオブジェクトの構築過程を分離し、同じ構築手順で異なる表現を生成できるようにする。"
  },
  {
    "question": "再帰関数のベースケースが欠けるとどうなる？",
    "options": [
      "無限再帰によりスタックオーバーフローが発生する",
      "関数が実行されない",
      "自動的にループに変換される",
      "コンパイルエラーになる"
    ],
    "answer": 0,
    "tags": ["data-structures"],
    "explanation": "再帰関数には必ず再帰を終了するベースケースが必要で、欠けると無限再帰によりスタックオーバーフローを引き起こす。"
  },
  {
    "question": "高階関数とは何か？",
    "options": [
      "関数を引数または戻り値として扱う関数",
      "最も高速に実行される関数",
      "グローバルスコープでのみ定義できる関数",
      "継承関係にある関数"
    ],
    "answer": 0,
    "tags": ["programming"],
    "explanation": "高階関数は他の関数を引数に受け取るか、関数を戻り値として返す関数で、関数型プログラミングの基本概念。"
  }
]
