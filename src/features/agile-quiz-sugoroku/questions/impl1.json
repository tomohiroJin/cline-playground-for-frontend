[
  {
    "question": "SOLIDのSが表す原則は？",
    "options": [
      "単一責任の原則",
      "安全性の原則",
      "拡張性の原則",
      "簡潔性の原則"
    ],
    "answer": 0,
    "tags": ["design-principles"]
  },
  {
    "question": "DRY原則の意味は？",
    "options": [
      "同じことを繰り返すな",
      "早く乾かせ",
      "ドキュメントを読め",
      "テストを書け"
    ],
    "answer": 0,
    "tags": ["design-principles"]
  },
  {
    "question": "O(n log n)の代表的ソートは？",
    "options": [
      "マージソート",
      "バブルソート",
      "選択ソート",
      "挿入ソート"
    ],
    "answer": 0,
    "tags": ["data-structures"]
  },
  {
    "question": "スタック(Stack)のアクセス方式は？",
    "options": [
      "LIFO",
      "FIFO",
      "ランダムアクセス",
      "優先度順"
    ],
    "answer": 0,
    "tags": ["data-structures"]
  },
  {
    "question": "KISS原則の意味は？",
    "options": [
      "シンプルに保て",
      "素早くイテレーション",
      "常にテスト",
      "ペアプロせよ"
    ],
    "answer": 0,
    "tags": ["design-principles"]
  },
  {
    "question": "ハッシュテーブルの平均探索計算量は？",
    "options": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n²)"
    ],
    "answer": 0,
    "tags": ["data-structures"]
  },
  {
    "question": "二分探索の前提条件は？",
    "options": [
      "ソート済み",
      "重複なし",
      "数値のみ",
      "固定長"
    ],
    "answer": 0,
    "tags": ["data-structures"]
  },
  {
    "question": "関数型プログラミングで重視される概念は？",
    "options": [
      "副作用のない純粋関数",
      "クラスの継承",
      "グローバル変数活用",
      "ポインタ操作"
    ],
    "answer": 0,
    "tags": ["programming"]
  },
  {
    "question": "Singletonパターンの特徴は？",
    "options": [
      "インスタンスを1つだけ生成",
      "複数IFを統合",
      "オブジェクト複製",
      "処理を並列化"
    ],
    "answer": 0,
    "tags": ["design-patterns"]
  },
  {
    "question": "SOLIDのOが表す原則は？",
    "options": [
      "開放閉鎖の原則",
      "最適化の原則",
      "OOP原則",
      "順序の原則"
    ],
    "answer": 0,
    "tags": ["design-principles"]
  },
  {
    "question": "再帰関数に必要不可欠な要素は？",
    "options": [
      "基底条件",
      "グローバル変数",
      "マルチスレッド",
      "例外処理"
    ],
    "answer": 0,
    "tags": ["programming"]
  },
  {
    "question": "連結リストの先頭挿入の計算量は？",
    "options": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n²)"
    ],
    "answer": 0,
    "tags": ["data-structures"]
  },
  {
    "question": "キュー(Queue)のアクセス方式は？",
    "options": [
      "FIFO",
      "LIFO",
      "ランダムアクセス",
      "優先度順"
    ],
    "answer": 0,
    "tags": ["data-structures"]
  },
  {
    "question": "ポリモーフィズムの主な利点は？",
    "options": [
      "同じIFで異なる振る舞い",
      "メモリ削減",
      "コンパイル短縮",
      "DB最適化"
    ],
    "answer": 0,
    "tags": ["programming"]
  },
  {
    "question": "バブルソートの最悪計算量は？",
    "options": [
      "O(n²)",
      "O(n)",
      "O(n log n)",
      "O(1)"
    ],
    "answer": 0,
    "tags": ["data-structures"]
  },
  {
    "question": "Observerパターンの用途は？",
    "options": [
      "状態変化を複数に通知",
      "データソート",
      "認証処理",
      "DB接続"
    ],
    "answer": 0,
    "tags": ["design-patterns"]
  },
  {
    "question": "ガベージコレクションの役割は？",
    "options": [
      "不要メモリの自動解放",
      "コード最適化",
      "テスト実行",
      "ログ出力"
    ],
    "answer": 0,
    "tags": ["programming"]
  },
  {
    "question": "木構造のBFSが使うデータ構造は？",
    "options": [
      "キュー",
      "スタック",
      "ハッシュマップ",
      "配列"
    ],
    "answer": 0,
    "tags": ["data-structures"]
  },
  {
    "question": "クロージャとは？",
    "options": [
      "外部変数を参照する関数",
      "クラスの一種",
      "ループ構文",
      "エラーハンドリング"
    ],
    "answer": 0,
    "tags": ["programming"]
  },
  {
    "question": "抽象クラスとIFの違いは？",
    "options": [
      "抽象クラスは実装を持てる",
      "違いはない",
      "IFは継承不可",
      "抽象は多重継承可"
    ],
    "answer": 0,
    "tags": ["programming"]
  },
  {
    "question": "Big-O記法で定数項や低次項を省略する理由は？",
    "options": [
      "入力サイズ増加時の支配的な傾向を見るため",
      "計算を簡単に見せるため",
      "厳密性が不要だから",
      "メモリ使用量を表すため"
    ],
    "answer": 0,
    "tags": ["data-structures"]
  },
  {
    "question": "インターフェース分離の原則(ISP)が避けたい状態は？",
    "options": [
      "使わないメソッドへの依存",
      "クラスの継承",
      "関数の分割",
      "自動テストの追加"
    ],
    "answer": 0,
    "tags": ["design-principles"]
  },
  {
    "question": "リファクタリングの目的として最も適切なのは？",
    "options": [
      "外部仕様を変えず内部品質を高める",
      "機能を必ず追加する",
      "テストを削除する",
      "リリース頻度を下げる"
    ],
    "answer": 0,
    "tags": ["refactoring"]
  },
  {
    "question": "依存性注入(DI)の利点は？",
    "options": [
      "結合度を下げてテストしやすくする",
      "実行速度を必ず最大化する",
      "例外処理を不要にする",
      "メモリ使用をゼロにする"
    ],
    "answer": 0,
    "tags": ["design-principles", "programming"]
  },
  {
    "question": "イミュータブルな設計の利点として適切なのは？",
    "options": [
      "状態変更バグを減らしやすい",
      "必ずコード量が減る",
      "通信回数がなくなる",
      "UIが自動生成される"
    ],
    "answer": 0,
    "tags": ["programming"]
  },
  {
    "question": "循環参照が増えると起きやすい問題は？",
    "options": [
      "変更影響の追跡が難しくなる",
      "テスト速度が必ず向上する",
      "ビルドが不要になる",
      "依存管理が不要になる"
    ],
    "answer": 0,
    "tags": ["design-principles", "code-quality"]
  },
  {
    "question": "境界値分析が有効な入力は？",
    "options": [
      "上限・下限が定義された値",
      "自由記述の感想文",
      "画像の色味",
      "乱数のみの値"
    ],
    "answer": 0,
    "tags": ["testing"]
  },
  {
    "question": "早すぎる最適化を避ける理由は？",
    "options": [
      "可読性と保守性を損なうリスクがあるため",
      "CPU使用率がゼロになるため",
      "設計不要になるため",
      "DBが不要になるため"
    ],
    "answer": 0,
    "tags": ["code-quality"]
  },
  {
    "question": "関心の分離(SoC)の狙いは？",
    "options": [
      "変更理由ごとにコードを分ける",
      "全処理を1ファイルに集約する",
      "命名を短縮する",
      "例外を無視する"
    ],
    "answer": 0,
    "tags": ["design-principles"]
  },
  {
    "question": "レイヤードアーキテクチャの利点は？",
    "options": [
      "責務が明確になり変更しやすい",
      "常に最速になる",
      "学習コストがゼロになる",
      "インフラが不要になる"
    ],
    "answer": 0,
    "tags": ["design-principles"]
  },
  {
    "question": "コード重複を許容する判断があり得る場面は？",
    "options": [
      "抽象化コストが価値を上回る初期段階",
      "常に全コードで許容",
      "本番障害中のみ恒久化",
      "レビューをしない場合"
    ],
    "answer": 0,
    "tags": ["code-quality", "design-principles"]
  },
  {
    "question": "N+1問題が起きやすい層は？",
    "options": [
      "データアクセス層の反復クエリ",
      "CSSレイアウト",
      "ルーティング定義",
      "型エイリアス定義"
    ],
    "answer": 0,
    "tags": ["programming"]
  },
  {
    "question": "アルゴリズム選択で最初に確認すべきことは？",
    "options": [
      "入力規模と制約条件",
      "開発者の好み",
      "エディタテーマ",
      "コメント量"
    ],
    "answer": 0,
    "tags": ["data-structures"]
  },
  {
    "question": "可読性の高い関数設計として適切なのは？",
    "options": [
      "短く単一責務で名前が意図を示す",
      "長く多機能で汎用名にする",
      "副作用を増やす",
      "引数を隠す"
    ],
    "answer": 0,
    "tags": ["code-quality"]
  },
  {
    "question": "マジックナンバーを避ける主な理由は？",
    "options": [
      "意味が不明で変更に弱くなるため",
      "実行速度が必ず下がるため",
      "型推論できないため",
      "テスト不能になるため"
    ],
    "answer": 0,
    "tags": ["code-quality"]
  },
  {
    "question": "フェイルファスト設計の考え方は？",
    "options": [
      "異常を早期検知し被害を最小化する",
      "例外を握りつぶす",
      "ログを出さない",
      "検証を後回しにする"
    ],
    "answer": 0,
    "tags": ["code-quality"]
  },
  {
    "question": "純粋関数の条件として正しいものは？",
    "options": [
      "同じ入力なら同じ出力で副作用がない",
      "内部状態を毎回更新する",
      "グローバル変数必須",
      "非同期でのみ動く"
    ],
    "answer": 0,
    "tags": ["programming"]
  },
  {
    "question": "APIの後方互換性を守る典型手段は？",
    "options": [
      "破壊的変更を避けバージョニングする",
      "常に同時置換する",
      "通知なしで削除する",
      "ドキュメントを省略する"
    ],
    "answer": 0,
    "tags": ["release", "design-principles"]
  },
  {
    "question": "メモ化(memoization)が有効なケースは？",
    "options": [
      "同じ計算を繰り返し呼ぶ純関数",
      "毎回乱数を返す処理",
      "副作用だらけの処理",
      "I/O待ち専用処理"
    ],
    "answer": 0,
    "tags": ["programming"]
  },
  {
    "question": "デッドコードを放置するリスクは？",
    "options": [
      "理解コストと誤変更リスクが増える",
      "バグが必ず減る",
      "レビュー不要になる",
      "容量が必ず減る"
    ],
    "answer": 0,
    "tags": ["code-quality"]
  },
  {
    "question": "設計原則YAGNIの意味は？",
    "options": [
      "今必要ない機能は作らない",
      "将来機能を必ず先に作る",
      "要件を無視する",
      "テストを後回しにする"
    ],
    "answer": 0,
    "tags": ["design-principles"]
  },
  {
    "question": "技術選定でPoCを行う主目的は？",
    "options": [
      "不確実性とリスクを早期に検証する",
      "正式導入を省略する",
      "全コードを書き直す",
      "見積もりを不要にする"
    ],
    "answer": 0,
    "tags": ["design-principles"]
  }
]
