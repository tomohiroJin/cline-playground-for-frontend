[
  {
    "question": "技術的負債とは？",
    "options": [
      "短期的解決策で将来発生する追加コスト",
      "金銭的借入",
      "未払いライセンス料",
      "サーバー老朽化"
    ],
    "answer": 0,
    "explanation": "負債は短期的妥協の長期的コスト。",
    "tags": ["refactoring"]
  },
  {
    "question": "リファクタリングの定義は？",
    "options": [
      "振る舞いを変えず内部構造を改善",
      "新機能追加",
      "バグ修正",
      "パフォーマンス最適化"
    ],
    "answer": 0,
    "explanation": "リファクタ＝外部振る舞い不変で内部改善。",
    "tags": ["refactoring"]
  },
  {
    "question": "コード可読性を高める最も基本的な方法は？",
    "options": [
      "適切な命名",
      "コメントを大量に",
      "1行にまとめる",
      "変数を減らす"
    ],
    "answer": 0,
    "explanation": "名前が意図を語れば、コメントなしでも読める。",
    "tags": ["code-quality"]
  },
  {
    "question": "コードスメルとは？",
    "options": [
      "深い問題を示唆する表面的兆候",
      "コンパイルエラー",
      "実行時エラー",
      "セキュリティ脆弱性"
    ],
    "answer": 0,
    "explanation": "エラーではないが設計上の問題を匂わせる兆候。",
    "tags": ["code-quality"]
  },
  {
    "question": "リファクタリングと機能追加の違いは？",
    "options": [
      "振る舞いを変えない",
      "常に高速化",
      "機能追加は構造改善",
      "違いはない"
    ],
    "answer": 0,
    "explanation": "リファクタリングは外部動作を保ったまま内部を整理する活動。",
    "tags": ["refactoring"]
  },
  {
    "question": "技術的負債蓄積で最も影響を受けるのは？",
    "options": [
      "変更コストと時間",
      "サーバー物理寿命",
      "チーム人数",
      "言語選択"
    ],
    "answer": 0,
    "explanation": "負債が溜まると小さな変更でも多大なコストと時間がかかる。",
    "tags": ["refactoring"]
  },
  {
    "question": "ボーイスカウトルールとは？",
    "options": [
      "コードを見つけた時より綺麗にして去る",
      "最小限の変更",
      "ドキュメント必須",
      "ペアプロ義務化"
    ],
    "answer": 0,
    "explanation": "来た時より美しく。継続的改善の精神。",
    "tags": ["refactoring", "code-quality"]
  },
  {
    "question": "循環的複雑度が高いコードの特徴は？",
    "options": [
      "分岐やループが多く理解困難",
      "行数が多い",
      "変数が多い",
      "関数が少ない"
    ],
    "answer": 0,
    "explanation": "分岐・ループが増えるほど経路が爆発し、理解もテストも難しくなる。",
    "tags": ["code-quality"]
  },
  {
    "question": "マジックナンバーとは？",
    "options": [
      "意味不明な数値リテラル",
      "乱数シード値",
      "暗号化キー",
      "バージョン番号"
    ],
    "answer": 0,
    "explanation": "意図が読み取れない裸の数値はバグと誤解の温床。",
    "tags": ["code-quality"]
  },
  {
    "question": "デッドコードとは？",
    "options": [
      "実行されないコード",
      "低速コード",
      "テストなしコード",
      "古い言語のコード"
    ],
    "answer": 0,
    "explanation": "到達不能なコードはノイズとなり可読性を下げる。",
    "tags": ["code-quality"]
  },
  {
    "question": "凝集度が高いモジュールの特徴は？",
    "options": [
      "関連機能がまとまっている",
      "多くの外部依存",
      "行数が少ない",
      "グローバル変数使用"
    ],
    "answer": 0,
    "explanation": "一つの責務に集中したモジュールは変更影響が小さく保守しやすい。",
    "tags": ["design-principles"]
  },
  {
    "question": "ロングメソッドが問題な理由は？",
    "options": [
      "理解・テスト・保守が困難",
      "実行速度低下",
      "メモリ不足",
      "命名困難"
    ],
    "answer": 0,
    "explanation": "長いメソッドは複数の責務を抱えやすく、変更時の影響把握が難しい。",
    "tags": ["code-quality"]
  },
  {
    "question": "神クラスの問題点は？",
    "options": [
      "責務集中で変更影響大",
      "パフォーマンス良すぎ",
      "テスト簡単すぎ",
      "依存少なすぎ"
    ],
    "answer": 0,
    "explanation": "一つのクラスに責務が集中すると、あらゆる変更が波及する。",
    "tags": ["code-quality", "design-principles"]
  },
  {
    "question": "Lintツールの主な目的は？",
    "options": [
      "コードスタイルや問題を自動検出",
      "コード自動修正",
      "テスト実行",
      "ビルド最適化"
    ],
    "answer": 0,
    "explanation": "人の目に頼らず機械的にスタイル違反や潜在バグを検出できる。",
    "tags": ["code-quality"]
  },
  {
    "question": "技術的負債の返済タイミングは？",
    "options": [
      "計画的に少しずつが理想",
      "一切返済しない",
      "PJ終了時",
      "お金が貯まったら"
    ],
    "answer": 0,
    "explanation": "一括返済は現実的でなく、日常的に少しずつ返すのが持続可能。",
    "tags": ["refactoring"]
  },
  {
    "question": "リファインメントで受け入れ条件を明確にする主目的は？",
    "options": [
      "完了判定の認識を揃える",
      "会議時間を延ばす",
      "担当を固定する",
      "工数を隠す"
    ],
    "answer": 0,
    "explanation": "「何をもって完了か」の認識がずれると手戻りが発生する。",
    "tags": ["backlog", "scrum"]
  },
  {
    "question": "依存関係が大きいPBIへの基本対応は？",
    "options": [
      "分割して先行検証できる形にする",
      "最後まで放置する",
      "見積もりしない",
      "常に緊急対応へ回す"
    ],
    "answer": 0,
    "explanation": "分割すればリスクを早期に検証でき、ブロッカーを減らせる。",
    "tags": ["backlog"]
  },
  {
    "question": "リファインメント参加者の基本構成は？",
    "options": [
      "POと開発者を中心に必要に応じSM",
      "POのみ",
      "マネージャーのみ",
      "顧客のみ"
    ],
    "answer": 0,
    "explanation": "価値判断のPOと技術判断の開発者が揃うことで精度が上がる。",
    "tags": ["scrum"]
  },
  {
    "question": "見積もり前に確認したい情報は？",
    "options": [
      "受け入れ条件と前提制約",
      "担当者の好み",
      "座席表",
      "休日予定のみ"
    ],
    "answer": 0,
    "explanation": "前提と制約が不明なまま見積もると精度が大きく下がる。",
    "tags": ["estimation", "backlog"]
  },
  {
    "question": "曖昧な要求への初動として適切なのは？",
    "options": [
      "質問を作り不明点を具体化する",
      "推測で実装開始",
      "要求を削除",
      "見積もりを固定"
    ],
    "answer": 0,
    "explanation": "曖昧さを放置した実装は高確率で手戻りになる。まず問いを立てる。",
    "tags": ["backlog"]
  },
  {
    "question": "大きすぎるPBIを分割する観点として有効なのは？",
    "options": [
      "ユーザー価値単位での切り分け",
      "担当者の年次順",
      "ファイル名順",
      "会議発言順"
    ],
    "answer": 0,
    "explanation": "価値単位で分割すれば、各PBIが独立してユーザーに届けられる。",
    "tags": ["backlog"]
  },
  {
    "question": "非機能要件をリファインメントで扱う理由は？",
    "options": [
      "後工程での手戻りを減らすため",
      "実装後にしか決められないため",
      "テストで自動決定されるため",
      "優先度が常に低いため"
    ],
    "answer": 0,
    "explanation": "性能やセキュリティ要件を後回しにすると大規模な作り直しになりやすい。",
    "tags": ["backlog"]
  },
  {
    "question": "依存関係の可視化で期待できる効果は？",
    "options": [
      "順序最適化とブロッカー回避",
      "必ず工数半減",
      "レビュー不要化",
      "障害ゼロ化"
    ],
    "answer": 0,
    "explanation": "依存を見える化すれば着手順序を最適化しブロッカーを事前に対処できる。",
    "tags": ["backlog"]
  },
  {
    "question": "スプリント前半でリファインメントする利点は？",
    "options": [
      "次スプリント候補を余裕を持って整備できる",
      "現在作業が不要になる",
      "会議数が必ずゼロになる",
      "見積もりが不要になる"
    ],
    "answer": 0,
    "explanation": "前半に備えておけば、プランニング時に慌てず精度の高い計画が立てられる。",
    "tags": ["scrum", "backlog"]
  },
  {
    "question": "DoDとの整合確認を行う目的は？",
    "options": [
      "完了基準とのギャップを早期発見する",
      "実装者を固定する",
      "見積もりを隠す",
      "顧客連絡を減らす"
    ],
    "answer": 0,
    "explanation": "完了の定義と合わない項目は手戻りの原因になるため早期確認が重要。",
    "tags": ["scrum", "backlog"]
  },
  {
    "question": "リファインメントで技術選択を議論する際のポイントは？",
    "options": [
      "トレードオフを明示して判断する",
      "流行だけで決める",
      "議論を記録しない",
      "全員一致まで延期する"
    ],
    "answer": 0,
    "explanation": "技術選択にはメリット・デメリットがあり、トレードオフの透明化が鍵。",
    "tags": ["backlog"]
  },
  {
    "question": "リファインメント成果物として有用なのは？",
    "options": [
      "更新済みバックログと明確な受け入れ条件",
      "議事録なし口頭合意のみ",
      "個人メモのみ",
      "未優先の要望一覧のみ"
    ],
    "answer": 0,
    "explanation": "口頭だけでは認識がずれる。記録された成果物がチームの共通理解になる。",
    "tags": ["backlog", "scrum"]
  },
  {
    "question": "見積もり不能な項目が出たときの対応は？",
    "options": [
      "調査タスクを分けて不確実性を減らす",
      "最小値で固定する",
      "最大値で固定する",
      "見積もりを省く"
    ],
    "answer": 0,
    "explanation": "不明点を調査タスクとして切り出せば、段階的に不確実性を下げられる。",
    "tags": ["estimation"]
  },
  {
    "question": "利害関係者の期待調整が必要な理由は？",
    "options": [
      "優先順位とスコープ認識を揃えるため",
      "会議時間を増やすため",
      "責任を曖昧にするため",
      "開発速度を下げるため"
    ],
    "answer": 0,
    "explanation": "期待がずれたまま進むとスプリント終了時に不満と手戻りが生じる。",
    "tags": ["backlog", "team"]
  },
  {
    "question": "バックログ項目のINVEST確認の目的は？",
    "options": [
      "実装可能で価値ある粒度に整えるため",
      "項目数を増やすため",
      "見積もりを禁止するため",
      "レビューを削減するため"
    ],
    "answer": 0,
    "explanation": "INVESTの6基準を満たす項目は見積もり・実装・検証がしやすい。",
    "tags": ["backlog"]
  },
  {
    "question": "リファインメントで仮説を置く利点は？",
    "options": [
      "検証前提を共有し学習を早められる",
      "失敗を隠せる",
      "要件を固定化できる",
      "運用監視を不要化できる"
    ],
    "answer": 0,
    "explanation": "仮説を明示すれば検証ポイントが明確になり、学びのサイクルが速まる。",
    "tags": ["backlog"]
  },
  {
    "question": "チームで見積もる価値は？",
    "options": [
      "知識を統合し認識差を減らせる",
      "POの負担をゼロ化する",
      "議論をなくせる",
      "実装順が固定化される"
    ],
    "answer": 0,
    "explanation": "複数の視点を統合することで見積もり精度が上がり認識のずれも減る。",
    "tags": ["estimation", "team"]
  },
  {
    "question": "PBIの完了イメージ共有に有効なのは？",
    "options": [
      "具体的な受け入れ例の提示",
      "抽象的スローガンのみ",
      "担当者任せ",
      "期限のみ共有"
    ],
    "answer": 0,
    "explanation": "具体例があれば完了イメージが揃い、手戻りを防げる。",
    "tags": ["backlog"]
  },
  {
    "question": "UX観点を早期に含める理由は？",
    "options": [
      "作り直しコストを抑えやすい",
      "テストが不要になる",
      "開発者が減らせる",
      "監視が不要になる"
    ],
    "answer": 0,
    "explanation": "UX課題を後から直すとUI・ロジック双方の大幅修正が必要になる。",
    "tags": ["backlog", "team"]
  },
  {
    "question": "リファインメントのやりすぎで起こる問題は？",
    "options": [
      "過剰分析で実装開始が遅れる",
      "品質が必ず低下する",
      "見積もりが不能になる",
      "顧客価値が消える"
    ],
    "answer": 0,
    "explanation": "分析麻痺に陥ると実装着手が遅れ、価値提供のタイミングを逃す。",
    "tags": ["scrum", "backlog"]
  },
  {
    "question": "不確実性を示すための実践として適切なのは？",
    "options": [
      "前提・リスク・未決事項を明記する",
      "数値だけ提示する",
      "口頭のみで管理する",
      "記録を残さない"
    ],
    "answer": 0,
    "explanation": "不確実性を文書化しておけば、判断の根拠と見直し時期が明確になる。",
    "tags": ["backlog"]
  },
  {
    "question": "継続的リファインメントの最終目的は？",
    "options": [
      "価値提供の流れを止めないこと",
      "計画を固定すること",
      "会議を増やすこと",
      "責任を分散すること"
    ],
    "answer": 0,
    "explanation": "リファインメントはバックログを常に準備完了状態に保ち、価値の流れを維持する活動。",
    "tags": ["scrum", "backlog"]
  },
  {
    "question": "リファクタリングの前提条件として最も重要なものは？",
    "options": [
      "十分なテストカバレッジがあること",
      "全チームメンバーの承認",
      "新しいフレームワークの導入",
      "ドキュメントの完全な更新"
    ],
    "answer": 0,
    "tags": ["refactoring"],
    "explanation": "リファクタリングは外部の振る舞いを変えないコード改善であり、変更が正しいことを保証するテストが不可欠。"
  },
  {
    "question": "技術的負債を可視化する方法として適切なものは？",
    "options": [
      "負債項目をバックログに登録して管理する",
      "負債を無視して機能開発を優先する",
      "負債の存在をチーム外に隠す",
      "すべての負債を一度に解消する"
    ],
    "answer": 0,
    "tags": ["refactoring", "backlog"],
    "explanation": "技術的負債をバックログアイテムとして可視化し、機能開発とのバランスを取りながら計画的に返済する。"
  },
  {
    "question": "コードスメルの「長いメソッド」への対処として適切なのは？",
    "options": [
      "メソッドの抽出で責務を分割する",
      "コメントを大量に追加する",
      "変数名を短くする",
      "メソッドをインライン化する"
    ],
    "answer": 0,
    "tags": ["refactoring", "code-quality"],
    "explanation": "長いメソッドはExtract Methodリファクタリングで意味のある小さなメソッドに分割し、可読性と再利用性を向上させる。"
  },
  {
    "question": "バックログのリファインメントに割くべき時間の目安は？",
    "options": [
      "スプリントのキャパシティの10%以下",
      "スプリントの50%以上",
      "時間制限なし",
      "スプリント外で行う"
    ],
    "answer": 0,
    "tags": ["scrum", "backlog"],
    "explanation": "Scrum Guideではリファインメントは通常スプリントのキャパシティの10%以下で実施するとされている。"
  },
  {
    "question": "ストラングラーフィグパターンの目的は？",
    "options": [
      "レガシーシステムを段階的に置き換える",
      "新システムを一度に全面移行する",
      "既存コードをそのまま維持する",
      "テストを全て削除する"
    ],
    "answer": 0,
    "tags": ["refactoring"],
    "explanation": "ストラングラーフィグパターンはレガシーシステムの機能を段階的に新システムに移行し、リスクを最小化する手法。"
  },
  {
    "question": "受け入れ基準(Acceptance Criteria)の役割は？",
    "options": [
      "ストーリーの完了条件を明確にする",
      "開発者の能力を評価する",
      "スプリント期間を決定する",
      "技術スタックを選定する"
    ],
    "answer": 0,
    "tags": ["backlog"],
    "explanation": "受け入れ基準はユーザーストーリーが「完了」と見なされるための具体的で検証可能な条件を定義する。"
  },
  {
    "question": "コードの循環的複雑度が高いとどうなる？",
    "options": [
      "テストケース数が増加しバグが混入しやすくなる",
      "実行速度が向上する",
      "メモリ使用量が減少する",
      "コンパイル時間が短縮される"
    ],
    "answer": 0,
    "tags": ["code-quality", "refactoring"],
    "explanation": "循環的複雑度が高いコードは分岐が多く、テストが困難でバグが混入しやすい。リファクタリングで複雑度を下げるべき。"
  },
  {
    "question": "Ready(準備完了)の定義に含めるべきものは？",
    "options": [
      "見積もり・受け入れ基準・チームの理解",
      "実装コードの完成",
      "テストの完了",
      "デプロイの実施"
    ],
    "answer": 0,
    "tags": ["backlog", "scrum"],
    "explanation": "Definition of Readyはバックログアイテムがスプリントに取り込める状態であることを示す基準で、見積もり・受け入れ基準・チームの理解を含む。"
  }
]
