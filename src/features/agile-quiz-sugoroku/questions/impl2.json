[
  {
    "question": "既存コード修正時に最も重要な考慮は？",
    "options": [
      "影響範囲の把握",
      "実装速度",
      "コメント追加",
      "変数名統一"
    ],
    "answer": 0,
    "tags": ["refactoring"],
    "explanation": "既存コードの修正では、変更がどこに波及するかを把握することが最優先。影響範囲を見誤るとデグレを招く。"
  },
  {
    "question": "副作用(Side Effect)とは？",
    "options": [
      "関数がスコープ外の状態を変更",
      "バグのこと",
      "パフォーマンス低下",
      "メモリリーク"
    ],
    "answer": 0,
    "tags": ["programming"],
    "explanation": "副作用とは関数が自身のスコープ外の状態（グローバル変数やI/O等）を変更すること。予測しにくいバグの原因になる。"
  },
  {
    "question": "密結合のデメリットは？",
    "options": [
      "一箇所の変更が広範囲に影響",
      "実行速度が遅い",
      "メモリ使用量大",
      "コード行数増加"
    ],
    "answer": 0,
    "tags": ["design-principles"],
    "explanation": "密結合ではモジュール間の依存が強く、一箇所の変更が連鎖的に他へ波及するため保守性が低下する。"
  },
  {
    "question": "DI(依存性注入)の目的は？",
    "options": [
      "結合度を下げる",
      "実行速度向上",
      "メモリ節約",
      "セキュリティ強化"
    ],
    "answer": 0,
    "tags": ["design-principles", "programming"],
    "explanation": "DI：外から依存を注入し結合度を下げる。"
  },
  {
    "question": "変更耐性の高いコードの特徴は？",
    "options": [
      "責務が適切に分離",
      "行数が少ない",
      "コメントが多い",
      "最新言語で記述"
    ],
    "answer": 0,
    "tags": ["design-principles"],
    "explanation": "責務が適切に分離されていれば、変更の影響が局所化され、修正しやすく壊れにくいコードになる。"
  },
  {
    "question": "デグレード(デグレ)とは？",
    "options": [
      "修正により既存機能が壊れること",
      "パフォーマンス向上",
      "バージョンアップ",
      "コード圧縮"
    ],
    "answer": 0,
    "tags": ["testing"],
    "explanation": "デグレ＝リグレッション。回帰テストで防ぐ。"
  },
  {
    "question": "フィーチャーフラグの目的は？",
    "options": [
      "機能ON/OFFをデプロイと分離",
      "コンパイル高速化",
      "セキュリティ強化",
      "ログ出力"
    ],
    "answer": 0,
    "tags": ["release"],
    "explanation": "フィーチャーフラグにより、コードをデプロイしても機能公開は別途制御できる。リスクを抑えた段階的リリースが可能になる。"
  },
  {
    "question": "SOLIDのDが表す原則は？",
    "options": [
      "依存性逆転の原則",
      "防御的プログラミング",
      "分散処理原則",
      "データ駆動原則"
    ],
    "answer": 0,
    "tags": ["design-principles"],
    "explanation": "DIP：上位は下位に依存せず抽象に依存。"
  },
  {
    "question": "ISPの意味は？",
    "options": [
      "不要メソッドへの依存を強制しない",
      "UI分離",
      "ネットワーク分離",
      "DB分離"
    ],
    "answer": 0,
    "tags": ["design-principles"],
    "explanation": "ISP（インターフェース分離の原則）は、クライアントが使わないメソッドへの依存を強制しないよう、インターフェースを適切に分割する原則。"
  },
  {
    "question": "後方互換性を維持する理由は？",
    "options": [
      "既存利用者に影響を与えない",
      "コードを短く",
      "新機能追加",
      "テスト省略"
    ],
    "answer": 0,
    "tags": ["release", "design-principles"],
    "explanation": "後方互換性を維持すれば、既存の利用者やシステムが変更の影響を受けずに動作し続けられる。"
  },
  {
    "question": "ストラングラーフィグパターンとは？",
    "options": [
      "旧システムを段階的に新に置換",
      "一括刷新",
      "テスト環境分離",
      "データ移行"
    ],
    "answer": 0,
    "tags": ["design-patterns"],
    "explanation": "ストラングラーフィグパターンは、旧システムを一括ではなく段階的に新システムへ置き換えることでリスクを最小化する手法。"
  },
  {
    "question": "セマンティックバージョニングでメジャー版を上げる条件は？",
    "options": [
      "後方互換性のない変更",
      "バグ修正",
      "新機能追加",
      "ドキュメント更新"
    ],
    "answer": 0,
    "tags": ["release"],
    "explanation": "セマンティックバージョニングではMAJOR.MINOR.PATCHの形式で、後方互換性を破る変更時にメジャー版を上げる。"
  },
  {
    "question": "アダプターパターンの目的は？",
    "options": [
      "互換性のないIFを変換し接続",
      "データ圧縮",
      "UI統一",
      "ログ出力"
    ],
    "answer": 0,
    "tags": ["design-patterns"],
    "explanation": "アダプターパターンは、互換性のないインターフェース同士を変換層で接続し、既存コードを変更せずに統合する設計パターン。"
  },
  {
    "question": "CIで最も重要な原則は？",
    "options": [
      "頻繁にメインブランチに統合",
      "月1回リリース",
      "手動テスト",
      "大きな変更をまとめる"
    ],
    "answer": 0,
    "tags": ["ci-cd"],
    "explanation": "CIの本質は頻繁にメインブランチへ統合し、問題を早期に検出すること。統合頻度が高いほど競合や不具合を小さく保てる。"
  },
  {
    "question": "リスコフの置換原則(LSP)とは？",
    "options": [
      "サブクラスは親と置換可能であるべき",
      "リスク管理",
      "リスト置換",
      "ログ置換"
    ],
    "answer": 0,
    "tags": ["design-principles"],
    "explanation": "LSPでは、サブクラスは親クラスと置き換えてもプログラムの正しさが保たれるべきとされる。継承の正しい使い方を規定する原則。"
  },
  {
    "question": "CIで毎回のビルドを速く保つ代表的な工夫は？",
    "options": [
      "テストの並列実行とキャッシュ活用",
      "毎回クリーンインストールのみ",
      "手動実行に切り替える",
      "通知を無効化する"
    ],
    "answer": 0,
    "tags": ["ci-cd"],
    "explanation": "テストの並列実行や依存キャッシュの活用により、CIビルドのフィードバックを高速に保ち開発効率を維持できる。"
  },
  {
    "question": "コードレビューで最も避けるべきレビューコメントは？",
    "options": [
      "人格を否定する指摘",
      "代替案付きの改善提案",
      "根拠付きの設計指摘",
      "可読性向上の提案"
    ],
    "answer": 0,
    "tags": ["team", "code-quality"],
    "explanation": "レビューはコードに対して行うもの。人格否定はチームの心理的安全性を損ない、建設的な議論を妨げる。"
  },
  {
    "question": "ブランチ戦略で短命ブランチを推奨する理由は？",
    "options": [
      "統合コストと競合リスクを下げるため",
      "レビューを不要にするため",
      "履歴を隠すため",
      "リリースを減らすため"
    ],
    "answer": 0,
    "tags": ["ci-cd"],
    "explanation": "ブランチが長命になるほどメインとの乖離が大きくなり、マージ時の競合や統合コストが増大する。"
  },
  {
    "question": "フィーチャーフラグ活用の利点は？",
    "options": [
      "デプロイとリリースを分離できる",
      "テストを省略できる",
      "障害が起きなくなる",
      "設計が不要になる"
    ],
    "answer": 0,
    "tags": ["release"],
    "explanation": "フィーチャーフラグによりデプロイ済みのコードでも機能公開を別途制御でき、リリースタイミングを柔軟に管理できる。"
  },
  {
    "question": "ペアプログラミングの効果として適切なのは？",
    "options": [
      "知識共有と欠陥早期発見",
      "必ず開発速度が2倍",
      "レビューが不要になる",
      "設計議論が不要になる"
    ],
    "answer": 0,
    "tags": ["team"],
    "explanation": "ペアプロはリアルタイムで知識を共有しつつ、もう一人の目で欠陥を早期発見できる。速度2倍は保証されない。"
  },
  {
    "question": "コードレビューの観点に含めるべきものは？",
    "options": [
      "可読性・設計整合・テスト妥当性",
      "作業時間のみ",
      "コメント量のみ",
      "行数のみ"
    ],
    "answer": 0,
    "tags": ["team", "code-quality"],
    "explanation": "レビューでは可読性・設計整合性・テスト妥当性など多角的な観点でコード品質を確認することが重要。"
  },
  {
    "question": "CI失敗時の基本対応として正しいのは？",
    "options": [
      "原因特定を優先し早期に修復する",
      "失敗を許容して進める",
      "通知を切る",
      "テストを削除する"
    ],
    "answer": 0,
    "tags": ["ci-cd"],
    "explanation": "CI失敗は全員の開発を阻害するため、原因を速やかに特定し修復することが最優先。放置するとCIの信頼性が失われる。"
  },
  {
    "question": "小さなPRを推奨する主な理由は？",
    "options": [
      "レビューしやすく品質を保ちやすい",
      "必ず実装量が増える",
      "CIが不要になる",
      "設計が不要になる"
    ],
    "answer": 0,
    "tags": ["team", "code-quality"],
    "explanation": "PRが小さいほどレビュー負荷が下がり、変更の意図が伝わりやすく、品質を保ちやすい。"
  },
  {
    "question": "リリースノートを整備する価値は？",
    "options": [
      "変更内容と影響を共有しやすい",
      "障害を隠せる",
      "テストを省略できる",
      "レビューを自動化できる"
    ],
    "answer": 0,
    "tags": ["release"],
    "explanation": "リリースノートにより、利用者や関係者が変更内容・影響範囲・注意点を把握しやすくなる。"
  },
  {
    "question": "トランクベース開発の前提として重要なのは？",
    "options": [
      "高頻度統合と自動テストの信頼性",
      "長期ブランチ運用",
      "手動マージのみ",
      "月次統合のみ"
    ],
    "answer": 0,
    "tags": ["ci-cd"],
    "explanation": "トランクベース開発では全員が頻繁にメインへ統合するため、自動テストの信頼性が高くないと品質を維持できない。"
  },
  {
    "question": "技術的負債返済を実装計画に含める理由は？",
    "options": [
      "将来の変更容易性を維持するため",
      "短期速度だけを上げるため",
      "仕様変更を防ぐため",
      "会議を減らすため"
    ],
    "answer": 0,
    "tags": ["refactoring"],
    "explanation": "技術的負債を放置すると変更コストが増大し続ける。計画的に返済することで将来の変更容易性を維持できる。"
  },
  {
    "question": "リファクタリング時の安全策として有効なのは？",
    "options": [
      "先にテストを整備してから変更する",
      "本番で直接確認する",
      "ログを無効化する",
      "差分を巨大化する"
    ],
    "answer": 0,
    "tags": ["refactoring", "testing"],
    "explanation": "リファクタリング前にテストを整備しておけば、振る舞いが変わっていないことを自動で検証でき安全に変更できる。"
  },
  {
    "question": "ドメイン知識をコードへ反映する方法として適切なのは？",
    "options": [
      "用語をモデルや命名に統一する",
      "略語だけ使う",
      "UI文言にのみ反映する",
      "コメントだけで管理する"
    ],
    "answer": 0,
    "tags": ["code-quality"],
    "explanation": "ドメインの用語をモデルや命名に統一することで、ビジネスとコードの対応が明確になり認識のずれを防げる。"
  },
  {
    "question": "レビュー待ちを減らす工夫として有効なのは？",
    "options": [
      "PRテンプレートで文脈を共有する",
      "差分説明を省略する",
      "担当者を固定しない",
      "通知を切る"
    ],
    "answer": 0,
    "tags": ["team"],
    "explanation": "PRテンプレートで変更の目的や確認ポイントを共有すれば、レビュアーが素早く文脈を把握でき待ち時間が短縮される。"
  },
  {
    "question": "パフォーマンス改善の進め方として適切なのは？",
    "options": [
      "計測してボトルネックから改善する",
      "勘で全体最適化する",
      "可読性を必ず犠牲にする",
      "監視を止める"
    ],
    "answer": 0,
    "tags": ["code-quality"],
    "explanation": "パフォーマンス改善は推測ではなく計測に基づき、最も効果の大きいボトルネックから対処するのが鉄則。"
  },
  {
    "question": "セマンティックバージョニングのPATCH更新は？",
    "options": [
      "後方互換なバグ修正",
      "破壊的変更",
      "新機能追加のみ",
      "仕様廃止のみ"
    ],
    "answer": 0,
    "tags": ["release"],
    "explanation": "PATCH更新は後方互換性を保ったバグ修正に限定される。新機能はMINOR、破壊的変更はMAJORで上げる。"
  },
  {
    "question": "デプロイ自動化の価値として適切なのは？",
    "options": [
      "人的ミス削減と再現性向上",
      "障害分析が不要になる",
      "監視が不要になる",
      "テストが不要になる"
    ],
    "answer": 0,
    "tags": ["ci-cd"],
    "explanation": "デプロイを自動化することで手作業による人的ミスを削減し、誰が実行しても同じ結果が得られる再現性を確保できる。"
  },
  {
    "question": "障害を防ぐためのプリマージチェックとして有効なのは？",
    "options": [
      "Lint・テスト・型チェックの自動実行",
      "レビュー省略",
      "手動確認のみ",
      "CI通知停止"
    ],
    "answer": 0,
    "tags": ["ci-cd", "testing"],
    "explanation": "マージ前にLint・テスト・型チェックを自動実行することで、人的見落としを防ぎ障害混入リスクを低減できる。"
  },
  {
    "question": "コード所有権を共有する利点は？",
    "options": [
      "属人化を防ぎ保守性を高める",
      "責任を曖昧にする",
      "レビューを減らす",
      "設計を固定する"
    ],
    "answer": 0,
    "tags": ["team"],
    "explanation": "コード所有権を共有すれば特定の人に依存せず、誰でも修正・改善でき保守性が向上する。"
  },
  {
    "question": "開発中ログ設計で意識すべき点は？",
    "options": [
      "調査に必要な文脈を構造化して残す",
      "個人情報を無制限に出す",
      "重要ログを削る",
      "ログレベルを固定しない"
    ],
    "answer": 0,
    "tags": ["sre"],
    "explanation": "障害調査時に必要な文脈（リクエストID・タイムスタンプ等）を構造化して残すことで、迅速な原因特定が可能になる。"
  },
  {
    "question": "リリース判定でGo/No-Goを行う主目的は？",
    "options": [
      "リスクと準備状況を確認する",
      "責任者を増やす",
      "ドキュメントを減らす",
      "仕様を凍結解除する"
    ],
    "answer": 0,
    "tags": ["release"],
    "explanation": "Go/No-Go判定は、リリースに伴うリスクと準備状況を関係者間で確認し、安全にリリースできるかを判断する場。"
  },
  {
    "question": "継続的改善のサイクルとして適切なのは？",
    "options": [
      "計測→学習→改善を反復する",
      "改善せず現状維持する",
      "改善を年1回に限定する",
      "失敗を記録しない"
    ],
    "answer": 0,
    "tags": ["team", "agile"],
    "explanation": "継続的改善は計測・学習・改善のサイクルを短い間隔で反復することで、チームやプロダクトを着実に成長させる。"
  }
]
