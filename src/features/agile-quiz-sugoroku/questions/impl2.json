[
  {
    "question": "既存コード修正時に最も重要な考慮は？",
    "options": [
      "影響範囲の把握",
      "実装速度",
      "コメント追加",
      "変数名統一"
    ],
    "answer": 0,
    "tags": ["refactoring"]
  },
  {
    "question": "副作用(Side Effect)とは？",
    "options": [
      "関数がスコープ外の状態を変更",
      "バグのこと",
      "パフォーマンス低下",
      "メモリリーク"
    ],
    "answer": 0,
    "tags": ["programming"]
  },
  {
    "question": "密結合のデメリットは？",
    "options": [
      "一箇所の変更が広範囲に影響",
      "実行速度が遅い",
      "メモリ使用量大",
      "コード行数増加"
    ],
    "answer": 0,
    "tags": ["design-principles"]
  },
  {
    "question": "DI(依存性注入)の目的は？",
    "options": [
      "結合度を下げる",
      "実行速度向上",
      "メモリ節約",
      "セキュリティ強化"
    ],
    "answer": 0,
    "tags": ["design-principles", "programming"]
  },
  {
    "question": "変更耐性の高いコードの特徴は？",
    "options": [
      "責務が適切に分離",
      "行数が少ない",
      "コメントが多い",
      "最新言語で記述"
    ],
    "answer": 0,
    "tags": ["design-principles"]
  },
  {
    "question": "デグレード(デグレ)とは？",
    "options": [
      "修正により既存機能が壊れること",
      "パフォーマンス向上",
      "バージョンアップ",
      "コード圧縮"
    ],
    "answer": 0,
    "tags": ["testing"]
  },
  {
    "question": "フィーチャーフラグの目的は？",
    "options": [
      "機能ON/OFFをデプロイと分離",
      "コンパイル高速化",
      "セキュリティ強化",
      "ログ出力"
    ],
    "answer": 0,
    "tags": ["release"]
  },
  {
    "question": "SOLIDのDが表す原則は？",
    "options": [
      "依存性逆転の原則",
      "防御的プログラミング",
      "分散処理原則",
      "データ駆動原則"
    ],
    "answer": 0,
    "tags": ["design-principles"]
  },
  {
    "question": "ISPの意味は？",
    "options": [
      "不要メソッドへの依存を強制しない",
      "UI分離",
      "ネットワーク分離",
      "DB分離"
    ],
    "answer": 0,
    "tags": ["design-principles"]
  },
  {
    "question": "後方互換性を維持する理由は？",
    "options": [
      "既存利用者に影響を与えない",
      "コードを短く",
      "新機能追加",
      "テスト省略"
    ],
    "answer": 0,
    "tags": ["release", "design-principles"]
  },
  {
    "question": "ストラングラーフィグパターンとは？",
    "options": [
      "旧システムを段階的に新に置換",
      "一括刷新",
      "テスト環境分離",
      "データ移行"
    ],
    "answer": 0,
    "tags": ["design-patterns"]
  },
  {
    "question": "セマンティックバージョニングでメジャー版を上げる条件は？",
    "options": [
      "後方互換性のない変更",
      "バグ修正",
      "新機能追加",
      "ドキュメント更新"
    ],
    "answer": 0,
    "tags": ["release"]
  },
  {
    "question": "アダプターパターンの目的は？",
    "options": [
      "互換性のないIFを変換し接続",
      "データ圧縮",
      "UI統一",
      "ログ出力"
    ],
    "answer": 0,
    "tags": ["design-patterns"]
  },
  {
    "question": "CIで最も重要な原則は？",
    "options": [
      "頻繁にメインブランチに統合",
      "月1回リリース",
      "手動テスト",
      "大きな変更をまとめる"
    ],
    "answer": 0,
    "tags": ["ci-cd"]
  },
  {
    "question": "リスコフの置換原則(LSP)とは？",
    "options": [
      "サブクラスは親と置換可能であるべき",
      "リスク管理",
      "リスト置換",
      "ログ置換"
    ],
    "answer": 0,
    "tags": ["design-principles"]
  },
  {
    "question": "CIで毎回のビルドを速く保つ代表的な工夫は？",
    "options": [
      "テストの並列実行とキャッシュ活用",
      "毎回クリーンインストールのみ",
      "手動実行に切り替える",
      "通知を無効化する"
    ],
    "answer": 0,
    "tags": ["ci-cd"]
  },
  {
    "question": "コードレビューで最も避けるべきレビューコメントは？",
    "options": [
      "人格を否定する指摘",
      "代替案付きの改善提案",
      "根拠付きの設計指摘",
      "可読性向上の提案"
    ],
    "answer": 0,
    "tags": ["team", "code-quality"]
  },
  {
    "question": "ブランチ戦略で短命ブランチを推奨する理由は？",
    "options": [
      "統合コストと競合リスクを下げるため",
      "レビューを不要にするため",
      "履歴を隠すため",
      "リリースを減らすため"
    ],
    "answer": 0,
    "tags": ["ci-cd"]
  },
  {
    "question": "フィーチャーフラグ活用の利点は？",
    "options": [
      "デプロイとリリースを分離できる",
      "テストを省略できる",
      "障害が起きなくなる",
      "設計が不要になる"
    ],
    "answer": 0,
    "tags": ["release"]
  },
  {
    "question": "ペアプログラミングの効果として適切なのは？",
    "options": [
      "知識共有と欠陥早期発見",
      "必ず開発速度が2倍",
      "レビューが不要になる",
      "設計議論が不要になる"
    ],
    "answer": 0,
    "tags": ["team"]
  },
  {
    "question": "コードレビューの観点に含めるべきものは？",
    "options": [
      "可読性・設計整合・テスト妥当性",
      "作業時間のみ",
      "コメント量のみ",
      "行数のみ"
    ],
    "answer": 0,
    "tags": ["team", "code-quality"]
  },
  {
    "question": "CI失敗時の基本対応として正しいのは？",
    "options": [
      "原因特定を優先し早期に修復する",
      "失敗を許容して進める",
      "通知を切る",
      "テストを削除する"
    ],
    "answer": 0,
    "tags": ["ci-cd"]
  },
  {
    "question": "小さなPRを推奨する主な理由は？",
    "options": [
      "レビューしやすく品質を保ちやすい",
      "必ず実装量が増える",
      "CIが不要になる",
      "設計が不要になる"
    ],
    "answer": 0,
    "tags": ["team", "code-quality"]
  },
  {
    "question": "リリースノートを整備する価値は？",
    "options": [
      "変更内容と影響を共有しやすい",
      "障害を隠せる",
      "テストを省略できる",
      "レビューを自動化できる"
    ],
    "answer": 0,
    "tags": ["release"]
  },
  {
    "question": "トランクベース開発の前提として重要なのは？",
    "options": [
      "高頻度統合と自動テストの信頼性",
      "長期ブランチ運用",
      "手動マージのみ",
      "月次統合のみ"
    ],
    "answer": 0,
    "tags": ["ci-cd"]
  },
  {
    "question": "技術的負債返済を実装計画に含める理由は？",
    "options": [
      "将来の変更容易性を維持するため",
      "短期速度だけを上げるため",
      "仕様変更を防ぐため",
      "会議を減らすため"
    ],
    "answer": 0,
    "tags": ["refactoring"]
  },
  {
    "question": "リファクタリング時の安全策として有効なのは？",
    "options": [
      "先にテストを整備してから変更する",
      "本番で直接確認する",
      "ログを無効化する",
      "差分を巨大化する"
    ],
    "answer": 0,
    "tags": ["refactoring", "testing"]
  },
  {
    "question": "ドメイン知識をコードへ反映する方法として適切なのは？",
    "options": [
      "用語をモデルや命名に統一する",
      "略語だけ使う",
      "UI文言にのみ反映する",
      "コメントだけで管理する"
    ],
    "answer": 0,
    "tags": ["code-quality"]
  },
  {
    "question": "レビュー待ちを減らす工夫として有効なのは？",
    "options": [
      "PRテンプレートで文脈を共有する",
      "差分説明を省略する",
      "担当者を固定しない",
      "通知を切る"
    ],
    "answer": 0,
    "tags": ["team"]
  },
  {
    "question": "パフォーマンス改善の進め方として適切なのは？",
    "options": [
      "計測してボトルネックから改善する",
      "勘で全体最適化する",
      "可読性を必ず犠牲にする",
      "監視を止める"
    ],
    "answer": 0,
    "tags": ["code-quality"]
  },
  {
    "question": "セマンティックバージョニングのPATCH更新は？",
    "options": [
      "後方互換なバグ修正",
      "破壊的変更",
      "新機能追加のみ",
      "仕様廃止のみ"
    ],
    "answer": 0,
    "tags": ["release"]
  },
  {
    "question": "デプロイ自動化の価値として適切なのは？",
    "options": [
      "人的ミス削減と再現性向上",
      "障害分析が不要になる",
      "監視が不要になる",
      "テストが不要になる"
    ],
    "answer": 0,
    "tags": ["ci-cd"]
  },
  {
    "question": "障害を防ぐためのプリマージチェックとして有効なのは？",
    "options": [
      "Lint・テスト・型チェックの自動実行",
      "レビュー省略",
      "手動確認のみ",
      "CI通知停止"
    ],
    "answer": 0,
    "tags": ["ci-cd", "testing"]
  },
  {
    "question": "コード所有権を共有する利点は？",
    "options": [
      "属人化を防ぎ保守性を高める",
      "責任を曖昧にする",
      "レビューを減らす",
      "設計を固定する"
    ],
    "answer": 0,
    "tags": ["team"]
  },
  {
    "question": "開発中ログ設計で意識すべき点は？",
    "options": [
      "調査に必要な文脈を構造化して残す",
      "個人情報を無制限に出す",
      "重要ログを削る",
      "ログレベルを固定しない"
    ],
    "answer": 0,
    "tags": ["sre"]
  },
  {
    "question": "リリース判定でGo/No-Goを行う主目的は？",
    "options": [
      "リスクと準備状況を確認する",
      "責任者を増やす",
      "ドキュメントを減らす",
      "仕様を凍結解除する"
    ],
    "answer": 0,
    "tags": ["release"]
  },
  {
    "question": "継続的改善のサイクルとして適切なのは？",
    "options": [
      "計測→学習→改善を反復する",
      "改善せず現状維持する",
      "改善を年1回に限定する",
      "失敗を記録しない"
    ],
    "answer": 0,
    "tags": ["team", "agile"]
  }
]
