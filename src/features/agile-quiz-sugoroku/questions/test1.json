[
  {
    "q": "ブラックボックステストの特徴は？",
    "o": [
      "内部構造を考慮せず入出力で検証",
      "ソースコードを直接確認",
      "開発者のみ実施",
      "自動化不可"
    ],
    "a": 0
  },
  {
    "q": "境界値分析で重点的にテストする値は？",
    "o": [
      "有効範囲の境界付近",
      "ランダムな値",
      "中央値",
      "最頻値"
    ],
    "a": 0
  },
  {
    "q": "単体テストが検証する粒度は？",
    "o": [
      "関数やメソッド単位",
      "システム全体",
      "ユーザーシナリオ",
      "ネットワーク通信"
    ],
    "a": 0
  },
  {
    "q": "テストカバレッジ100%が保証するものは？",
    "o": [
      "全コードパスが実行されたこと",
      "バグがゼロ",
      "全要件を満たす",
      "テストが完璧"
    ],
    "a": 0
  },
  {
    "q": "結合テストの主な目的は？",
    "o": [
      "モジュール間の連携を検証",
      "UIデザイン確認",
      "パフォーマンス計測",
      "セキュリティ検証"
    ],
    "a": 0
  },
  {
    "q": "TDDの基本サイクルは？",
    "o": [
      "Red → Green → Refactor",
      "Plan → Code → Test",
      "Write → Run → Fix",
      "Design → Build → Deploy"
    ],
    "a": 0
  },
  {
    "q": "ホワイトボックステストの特徴は？",
    "o": [
      "内部構造を理解した上で検証",
      "ユーザー視点のみ",
      "ランダム入力",
      "本番環境のみ"
    ],
    "a": 0
  },
  {
    "q": "同値分割法の考え方は？",
    "o": [
      "同結果の入力をグループ化",
      "全入力を個別にテスト",
      "最悪ケースのみ",
      "出力のみ確認"
    ],
    "a": 0
  },
  {
    "q": "スモークテストの目的は？",
    "o": [
      "基本機能が動作するか素早く確認",
      "負荷耐性確認",
      "セキュリティホール発見",
      "全機能網羅確認"
    ],
    "a": 0
  },
  {
    "q": "モックオブジェクトの主な用途は？",
    "o": [
      "外部依存を模倣しテスト独立",
      "本番データ使用",
      "テスト高速化",
      "UI描画"
    ],
    "a": 0
  },
  {
    "q": "テストフィクスチャとは？",
    "o": [
      "テスト実行に必要な前提条件や初期データ",
      "自動化ツール",
      "結果レポート",
      "テンプレート"
    ],
    "a": 0
  },
  {
    "q": "ミューテーションテストの目的は？",
    "o": [
      "テストの品質を評価",
      "コードを変異させる",
      "負荷テスト",
      "UIテスト"
    ],
    "a": 0
  },
  {
    "q": "テストダブルに含まれないものは？",
    "o": [
      "コンパイラ",
      "スタブ",
      "モック",
      "スパイ"
    ],
    "a": 0
  },
  {
    "q": "探索的テストの特徴は？",
    "o": [
      "スクリプトなしで同時に学習・テスト",
      "自動テストの一種",
      "負荷テスト",
      "回帰テスト"
    ],
    "a": 0
  },
  {
    "q": "ペアワイズテストの目的は？",
    "o": [
      "パラメータ組み合わせを効率的にテスト",
      "2人で行うテスト",
      "ペアプロ検証",
      "2回テスト"
    ],
    "a": 0
  },
  {
    "q": "モックを使う主な目的は？",
    "o": [
      "外部依存を切り離して挙動を検証する",
      "実運用環境を完全再現する",
      "テストを手動化する",
      "本番データを直接使う"
    ],
    "a": 0
  },
  {
    "q": "テストケースを最小単位で独立させる利点は？",
    "o": [
      "失敗原因を特定しやすい",
      "実行順依存を増やせる",
      "コード量を必ず増やせる",
      "レビューが不要になる"
    ],
    "a": 0
  },
  {
    "q": "単体テストで外部API呼び出しを避ける理由は？",
    "o": [
      "テストを安定・高速に保つため",
      "ネットワークを必ず使うため",
      "本番依存を増やすため",
      "仕様確認を省くため"
    ],
    "a": 0
  },
  {
    "q": "テスト名に期待される情報は？",
    "o": [
      "条件・操作・期待結果",
      "作者名のみ",
      "チケット番号のみ",
      "実行時間のみ"
    ],
    "a": 0
  },
  {
    "q": "Given-When-Then形式の利点は？",
    "o": [
      "前提と期待結果が読み取りやすい",
      "実装詳細を隠せる",
      "テスト数を減らせる",
      "失敗時ログが不要になる"
    ],
    "a": 0
  },
  {
    "q": "アサーションが多すぎる1テストの問題は？",
    "o": [
      "失敗時の原因切り分けが難しい",
      "必ず品質が上がる",
      "実行速度が必ず上がる",
      "保守が不要になる"
    ],
    "a": 0
  },
  {
    "q": "テストピラミッドで推奨される比率は？",
    "o": [
      "単体テストを厚く上位を薄く",
      "E2Eを最大化する",
      "全層同数にする",
      "手動テストのみ"
    ],
    "a": 0
  },
  {
    "q": "フレーキーテストへの第一対応として適切なのは？",
    "o": [
      "原因を特定して再現性を改善する",
      "常にリトライ回数を増やす",
      "失敗を無視する",
      "テストを全削除する"
    ],
    "a": 0
  },
  {
    "q": "境界値テストで狙う不具合は？",
    "o": [
      "端の条件で起こる判定ミス",
      "UI配色の好み",
      "会議不足",
      "命名規則違反のみ"
    ],
    "a": 0
  },
  {
    "q": "回帰テストスイートを維持するポイントは？",
    "o": [
      "価値の低い重複ケースを整理する",
      "失敗ケースを残さない",
      "期待値を毎回変更する",
      "結果を記録しない"
    ],
    "a": 0
  },
  {
    "q": "テストデータを固定化する利点は？",
    "o": [
      "再現性を高めて比較しやすい",
      "常に現実性が上がる",
      "データ管理が不要になる",
      "テスト実装が不要になる"
    ],
    "a": 0
  },
  {
    "q": "AAAパターンのAは何を示す？",
    "o": [
      "Arrange/Act/Assertの構造",
      "Always/Any/All",
      "API/Adapter/Auth",
      "Async/Await/Abort"
    ],
    "a": 0
  },
  {
    "q": "契約テストの目的は？",
    "o": [
      "サービス間インターフェースの整合確認",
      "UI装飾の確認",
      "個人評価",
      "ビルド速度計測のみ"
    ],
    "a": 0
  },
  {
    "q": "スナップショットテストで注意すべき点は？",
    "o": [
      "差分の意味をレビューすること",
      "常に自動更新すること",
      "失敗を放置すること",
      "ユニットテストを削除すること"
    ],
    "a": 0
  },
  {
    "q": "テストで乱数を扱うときの基本は？",
    "o": [
      "シード固定や疑似乱数で再現性を持たせる",
      "毎回完全ランダムにする",
      "結果確認をしない",
      "ログを消す"
    ],
    "a": 0
  },
  {
    "q": "例外系テストの価値は？",
    "o": [
      "失敗時の振る舞い保証につながる",
      "正常系テストを不要にする",
      "設計を固定化する",
      "速度だけを改善する"
    ],
    "a": 0
  },
  {
    "q": "テストコードのリファクタリングが必要な理由は？",
    "o": [
      "可読性と保守性を維持するため",
      "本番コードを隠すため",
      "失敗を減らすためだけ",
      "レビューを省略するため"
    ],
    "a": 0
  },
  {
    "q": "E2Eテストを実行する適切なタイミングは？",
    "o": [
      "主要ユーザーフローの変更時やリリース前",
      "毎保存時に全件実行",
      "障害時のみ",
      "開発終了後のみ"
    ],
    "a": 0
  },
  {
    "q": "テスト失敗時にまず確認すべきことは？",
    "o": [
      "仕様変更か不具合かの切り分け",
      "担当者の評価",
      "CI料金",
      "コミットメッセージ長"
    ],
    "a": 0
  },
  {
    "q": "ミューテーションテストの目的は？",
    "o": [
      "テストの検出力を評価する",
      "本番コードを難読化する",
      "デプロイを高速化する",
      "Lintを置き換える"
    ],
    "a": 0
  },
  {
    "q": "テストケースレビューの効果は？",
    "o": [
      "観点漏れを早期に発見できる",
      "実装が不要になる",
      "バグ報告が不要になる",
      "運用監視が不要になる"
    ],
    "a": 0
  },
  {
    "q": "失敗メッセージを具体化する利点は？",
    "o": [
      "修正までの調査時間を短縮できる",
      "テスト数を減らせる",
      "本番障害がなくなる",
      "設計が自動生成される"
    ],
    "a": 0
  }
]
