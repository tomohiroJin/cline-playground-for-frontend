[
  {
    "question": "ブラックボックステストの特徴は？",
    "options": [
      "内部構造を考慮せず入出力で検証",
      "ソースコードを直接確認",
      "開発者のみ実施",
      "自動化不可"
    ],
    "answer": 0,
    "tags": ["testing"],
    "explanation": "BBT：仕様ベースで内部を見ない。"
  },
  {
    "question": "境界値分析で重点的にテストする値は？",
    "options": [
      "有効範囲の境界付近",
      "ランダムな値",
      "中央値",
      "最頻値"
    ],
    "answer": 0,
    "tags": ["testing"],
    "explanation": "バグは境界付近に集中しやすいため、有効範囲の端を重点的に検証する。"
  },
  {
    "question": "単体テストが検証する粒度は？",
    "options": [
      "関数やメソッド単位",
      "システム全体",
      "ユーザーシナリオ",
      "ネットワーク通信"
    ],
    "answer": 0,
    "tags": ["testing"],
    "explanation": "単体テストは関数やメソッドなど最小単位のロジックを検証する。"
  },
  {
    "question": "テストカバレッジ100%が保証するものは？",
    "options": [
      "全コードパスが実行されたこと",
      "バグがゼロ",
      "全要件を満たす",
      "テストが完璧"
    ],
    "answer": 0,
    "tags": ["testing"],
    "explanation": "カバレッジ100%はコードが実行されたことを示すだけで、バグゼロや要件充足を保証しない。"
  },
  {
    "question": "結合テストの主な目的は？",
    "options": [
      "モジュール間の連携を検証",
      "UIデザイン確認",
      "パフォーマンス計測",
      "セキュリティ検証"
    ],
    "answer": 0,
    "tags": ["testing"],
    "explanation": "結合テストは複数モジュールを組み合わせた際のインターフェースやデータ連携を検証する。"
  },
  {
    "question": "TDDの基本サイクルは？",
    "options": [
      "Red → Green → Refactor",
      "Plan → Code → Test",
      "Write → Run → Fix",
      "Design → Build → Deploy"
    ],
    "answer": 0,
    "tags": ["testing"],
    "explanation": "TDD：テスト先行で設計を駆動する。"
  },
  {
    "question": "ホワイトボックステストの特徴は？",
    "options": [
      "内部構造を理解した上で検証",
      "ユーザー視点のみ",
      "ランダム入力",
      "本番環境のみ"
    ],
    "answer": 0,
    "tags": ["testing"],
    "explanation": "WBTはコードの分岐やパスを把握し、内部ロジックの正しさを検証する。"
  },
  {
    "question": "同値分割法の考え方は？",
    "options": [
      "同結果の入力をグループ化",
      "全入力を個別にテスト",
      "最悪ケースのみ",
      "出力のみ確認"
    ],
    "answer": 0,
    "tags": ["testing"],
    "explanation": "同じ結果が期待される入力をグループ化し、代表値でテストすることで効率を上げる。"
  },
  {
    "question": "スモークテストの目的は？",
    "options": [
      "基本機能が動作するか素早く確認",
      "負荷耐性確認",
      "セキュリティホール発見",
      "全機能網羅確認"
    ],
    "answer": 0,
    "tags": ["testing"],
    "explanation": "スモークテストはビルド後に基本機能が動くか素早く確認する簡易テストである。"
  },
  {
    "question": "モックオブジェクトの主な用途は？",
    "options": [
      "外部依存を模倣しテスト独立",
      "本番データ使用",
      "テスト高速化",
      "UI描画"
    ],
    "answer": 0,
    "tags": ["testing"],
    "explanation": "モックで外部依存を切り離す。"
  },
  {
    "question": "テストフィクスチャとは？",
    "options": [
      "テスト実行に必要な前提条件や初期データ",
      "自動化ツール",
      "結果レポート",
      "テンプレート"
    ],
    "answer": 0,
    "tags": ["testing"],
    "explanation": "フィクスチャはテスト実行前に整える前提条件やデータのセットアップを指す。"
  },
  {
    "question": "ミューテーションテストの目的は？",
    "options": [
      "テストの品質を評価",
      "コードを変異させる",
      "負荷テスト",
      "UIテスト"
    ],
    "answer": 0,
    "tags": ["testing"],
    "explanation": "コードに意図的な変異を加え、テストがそれを検出できるかでテスト品質を評価する。"
  },
  {
    "question": "テストダブルに含まれないものは？",
    "options": [
      "コンパイラ",
      "スタブ",
      "モック",
      "スパイ"
    ],
    "answer": 0,
    "tags": ["testing"],
    "explanation": "テストダブルはスタブ・モック・スパイ等の代替物の総称で、コンパイラは含まれない。"
  },
  {
    "question": "探索的テストの特徴は？",
    "options": [
      "スクリプトなしで同時に学習・テスト",
      "自動テストの一種",
      "負荷テスト",
      "回帰テスト"
    ],
    "answer": 0,
    "tags": ["testing"],
    "explanation": "探索的テストはテスト設計と実行を同時に行い、対象を学習しながら欠陥を発見する。"
  },
  {
    "question": "ペアワイズテストの目的は？",
    "options": [
      "パラメータ組み合わせを効率的にテスト",
      "2人で行うテスト",
      "ペアプロ検証",
      "2回テスト"
    ],
    "answer": 0,
    "tags": ["testing"],
    "explanation": "全組み合わせではなく2因子間の組み合わせを網羅し、テスト数を大幅に削減する。"
  },
  {
    "question": "モックを使う主な目的は？",
    "options": [
      "外部依存を切り離して挙動を検証する",
      "実運用環境を完全再現する",
      "テストを手動化する",
      "本番データを直接使う"
    ],
    "answer": 0,
    "tags": ["testing"],
    "explanation": "モックにより外部サービスやDBへの依存を排除し、対象コードの挙動だけを検証できる。"
  },
  {
    "question": "テストケースを最小単位で独立させる利点は？",
    "options": [
      "失敗原因を特定しやすい",
      "実行順依存を増やせる",
      "コード量を必ず増やせる",
      "レビューが不要になる"
    ],
    "answer": 0,
    "tags": ["testing"],
    "explanation": "テストが独立していれば、失敗時にどの機能に問題があるか即座に特定できる。"
  },
  {
    "question": "単体テストで外部API呼び出しを避ける理由は？",
    "options": [
      "テストを安定・高速に保つため",
      "ネットワークを必ず使うため",
      "本番依存を増やすため",
      "仕様確認を省くため"
    ],
    "answer": 0,
    "tags": ["testing"],
    "explanation": "外部APIはネットワーク状態に左右されるため、テストの安定性と速度を損なう。"
  },
  {
    "question": "テスト名に期待される情報は？",
    "options": [
      "条件・操作・期待結果",
      "作者名のみ",
      "チケット番号のみ",
      "実行時間のみ"
    ],
    "answer": 0,
    "tags": ["testing"],
    "explanation": "テスト名に条件・操作・期待結果を含めることで、失敗時に内容を即座に把握できる。"
  },
  {
    "question": "Given-When-Then形式の利点は？",
    "options": [
      "前提と期待結果が読み取りやすい",
      "実装詳細を隠せる",
      "テスト数を減らせる",
      "失敗時ログが不要になる"
    ],
    "answer": 0,
    "tags": ["testing"],
    "explanation": "前提条件・操作・期待結果を明確に分離し、テストの意図を読み手に伝えやすくする。"
  },
  {
    "question": "アサーションが多すぎる1テストの問題は？",
    "options": [
      "失敗時の原因切り分けが難しい",
      "必ず品質が上がる",
      "実行速度が必ず上がる",
      "保守が不要になる"
    ],
    "answer": 0,
    "tags": ["testing"],
    "explanation": "アサーションが多いと最初の失敗で停止し、他の検証結果が得られず原因特定が困難になる。"
  },
  {
    "question": "テストピラミッドで推奨される比率は？",
    "options": [
      "単体テストを厚く上位を薄く",
      "E2Eを最大化する",
      "全層同数にする",
      "手動テストのみ"
    ],
    "answer": 0,
    "tags": ["testing"],
    "explanation": "単体テストを土台に厚く保ち、上位のE2Eは薄くすることで速度とコストを最適化する。"
  },
  {
    "question": "フレーキーテストへの第一対応として適切なのは？",
    "options": [
      "原因を特定して再現性を改善する",
      "常にリトライ回数を増やす",
      "失敗を無視する",
      "テストを全削除する"
    ],
    "answer": 0,
    "tags": ["testing"],
    "explanation": "不安定テストはリトライで隠すのではなく、根本原因を特定して再現性を改善すべきである。"
  },
  {
    "question": "境界値テストで狙う不具合は？",
    "options": [
      "端の条件で起こる判定ミス",
      "UI配色の好み",
      "会議不足",
      "命名規則違反のみ"
    ],
    "answer": 0,
    "tags": ["testing"],
    "explanation": "off-by-oneエラーなど、条件の端で起こりやすい判定ミスを狙って検出する。"
  },
  {
    "question": "回帰テストスイートを維持するポイントは？",
    "options": [
      "価値の低い重複ケースを整理する",
      "失敗ケースを残さない",
      "期待値を毎回変更する",
      "結果を記録しない"
    ],
    "answer": 0,
    "tags": ["testing"],
    "explanation": "重複や価値の低いケースを定期的に整理し、スイートの実行速度と保守性を維持する。"
  },
  {
    "question": "テストデータを固定化する利点は？",
    "options": [
      "再現性を高めて比較しやすい",
      "常に現実性が上がる",
      "データ管理が不要になる",
      "テスト実装が不要になる"
    ],
    "answer": 0,
    "tags": ["testing"],
    "explanation": "テストデータを固定することで結果が安定し、変更前後の比較が容易になる。"
  },
  {
    "question": "AAAパターンのAは何を示す？",
    "options": [
      "Arrange/Act/Assertの構造",
      "Always/Any/All",
      "API/Adapter/Auth",
      "Async/Await/Abort"
    ],
    "answer": 0,
    "tags": ["testing"],
    "explanation": "Arrange（準備）・Act（実行）・Assert（検証）の3段構成でテストを整理する。"
  },
  {
    "question": "契約テストの目的は？",
    "options": [
      "サービス間インターフェースの整合確認",
      "UI装飾の確認",
      "個人評価",
      "ビルド速度計測のみ"
    ],
    "answer": 0,
    "tags": ["testing"],
    "explanation": "契約テストはプロバイダとコンシューマ間のAPI仕様の整合性を自動的に検証する。"
  },
  {
    "question": "スナップショットテストで注意すべき点は？",
    "options": [
      "差分の意味をレビューすること",
      "常に自動更新すること",
      "失敗を放置すること",
      "ユニットテストを削除すること"
    ],
    "answer": 0,
    "tags": ["testing"],
    "explanation": "スナップショット更新時は差分の意味を確認し、意図しない変更を見逃さないことが重要。"
  },
  {
    "question": "テストで乱数を扱うときの基本は？",
    "options": [
      "シード固定や疑似乱数で再現性を持たせる",
      "毎回完全ランダムにする",
      "結果確認をしない",
      "ログを消す"
    ],
    "answer": 0,
    "tags": ["testing"],
    "explanation": "シードを固定して再現性を確保し、失敗時に同じ条件で再実行できるようにする。"
  },
  {
    "question": "例外系テストの価値は？",
    "options": [
      "失敗時の振る舞い保証につながる",
      "正常系テストを不要にする",
      "設計を固定化する",
      "速度だけを改善する"
    ],
    "answer": 0,
    "tags": ["testing"],
    "explanation": "異常系の振る舞いを検証することで、障害時にも安全に動作することを保証できる。"
  },
  {
    "question": "テストコードのリファクタリングが必要な理由は？",
    "options": [
      "可読性と保守性を維持するため",
      "本番コードを隠すため",
      "失敗を減らすためだけ",
      "レビューを省略するため"
    ],
    "answer": 0,
    "tags": ["testing", "refactoring"],
    "explanation": "テストコードも本番コード同様に可読性と保守性を維持しないと、変更コストが増大する。"
  },
  {
    "question": "E2Eテストを実行する適切なタイミングは？",
    "options": [
      "主要ユーザーフローの変更時やリリース前",
      "毎保存時に全件実行",
      "障害時のみ",
      "開発終了後のみ"
    ],
    "answer": 0,
    "tags": ["testing"],
    "explanation": "E2Eテストは実行コストが高いため、主要フロー変更時やリリース前に絞って実施する。"
  },
  {
    "question": "テスト失敗時にまず確認すべきことは？",
    "options": [
      "仕様変更か不具合かの切り分け",
      "担当者の評価",
      "CI料金",
      "コミットメッセージ長"
    ],
    "answer": 0,
    "tags": ["testing"],
    "explanation": "失敗が仕様変更による期待値の更新漏れか、実際の不具合かをまず切り分ける。"
  },
  {
    "question": "ミューテーションテストの目的は？",
    "options": [
      "テストの検出力を評価する",
      "本番コードを難読化する",
      "デプロイを高速化する",
      "Lintを置き換える"
    ],
    "answer": 0,
    "tags": ["testing"],
    "explanation": "変異させたコードをテストが検出できるかで、テストスイートの検出力を定量的に評価する。"
  },
  {
    "question": "テストケースレビューの効果は？",
    "options": [
      "観点漏れを早期に発見できる",
      "実装が不要になる",
      "バグ報告が不要になる",
      "運用監視が不要になる"
    ],
    "answer": 0,
    "tags": ["testing"],
    "explanation": "テストケースを複数人でレビューすることで、個人では気づかない観点漏れを早期に発見できる。"
  },
  {
    "question": "失敗メッセージを具体化する利点は？",
    "options": [
      "修正までの調査時間を短縮できる",
      "テスト数を減らせる",
      "本番障害がなくなる",
      "設計が自動生成される"
    ],
    "answer": 0,
    "tags": ["testing"],
    "explanation": "具体的な失敗メッセージにより期待値と実測値の差が明確になり、調査時間を短縮できる。"
  }
]
