/**
 * Agile Quiz Sugoroku - 問題データ
 */
import { QuestionsByCategory } from './types';

export const QUESTIONS: QuestionsByCategory = {
  planning: [
    { q: 'スクラムにおいてプロダクトの価値を最大化する責任を持つ役割は？', o: ['プロダクトオーナー', 'スクラムマスター', '開発者', 'ステークホルダー'], a: 0 },
    { q: 'スプリントプランニングの主な目的は？', o: ['スプリントゴールとバックログの策定', '前スプリントの振り返り', '成果物のデモ', '技術的負債の整理'], a: 0 },
    { q: 'プランニングポーカーのフィボナッチ数列の正しい並びは？', o: ['1,2,3,5,8,13', '1,2,4,8,16,32', '1,3,5,7,9,11', '1,2,3,4,5,6'], a: 0 },
    { q: 'ウォーターフォール開発の最も適切な特徴は？', o: ['各工程を順番に完了させてから次へ', '短いサイクルで反復', '計画を持たず柔軟に', 'テストを最初に行う'], a: 0 },
    { q: 'スクラムのスプリント期間の推奨最大長は？', o: ['1ヶ月', '2週間', '3ヶ月', '1週間'], a: 0 },
    { q: 'ベロシティとは何を示す指標か？', o: ['1スプリントで完了させた作業量', 'バグの発生率', 'コードの行数', '会議の回数'], a: 0 },
    { q: 'ストーリーポイントが表すものは？', o: ['作業の相対的な大きさ・複雑さ', '実装の正確な時間', '必要な人数', 'コードの行数'], a: 0 },
    { q: 'プロダクトバックログの並び順の最も一般的な基準は？', o: ['価値・優先度', '実装の容易さ', 'アルファベット順', '作成日順'], a: 0 },
    { q: 'スクラムマスターの主な役割は？', o: ['スクラムの理解と実践を促進', 'タスクを割り振る', 'コードレビュー', '要件を決定'], a: 0 },
    { q: 'MoSCoW法のMは何を表す？', o: ['Must have', 'Maybe', 'Most likely', 'Minimal'], a: 0 },
    { q: 'アジャイル宣言で「プロセスやツールよりも」重視されるのは？', o: ['個人と対話', '包括的なドキュメント', '契約交渉', '計画への追従'], a: 0 },
    { q: 'デイリースクラムの推奨時間は？', o: ['15分以内', '30分以内', '1時間以内', '時間制限なし'], a: 0 },
    { q: 'スクラムの3本柱に含まれないものは？', o: ['予測', '透明性', '検査', '適応'], a: 0 },
    { q: 'ユーザーストーリーの一般的な記述形式は？', o: ['〈誰〉として〈何〉がしたい', '〈機能名〉：〈実装詳細〉', 'IF〈条件〉THEN〈結果〉', '〈画面〉→〈操作〉→〈結果〉'], a: 0 },
    { q: 'スプリントバックログの所有者は？', o: ['開発チーム', 'プロダクトオーナー', 'スクラムマスター', 'マネージャー'], a: 0 },
    { q: 'WIP制限の目的は？', o: ['同時作業数を制限し効率を上げる', 'チーム人数を制限', '会議時間を制限', 'コード行数を制限'], a: 0 },
    { q: 'カンバンボードの基本カラム構成は？', o: ['To Do・In Progress・Done', '計画・実装・テスト', '要件・設計・開発', 'バグ・改善・機能'], a: 0 },
    { q: 'スプリントゴールの役割は？', o: ['達成すべき目的を明確にする', 'タスク割当を決める', '締め切り設定', '予算管理'], a: 0 },
    { q: 'リファインメントに費やす推奨時間は？', o: ['スプリント全体の10%以下', '50%以上', '1日丸ごと', '制限なし'], a: 0 },
    { q: 'Tシャツサイジングとは何のための手法か？', o: ['大まかな見積もり', 'コードレビュー', 'テスト分類', 'リリース判定'], a: 0 },
  ],
  impl1: [
    { q: 'SOLIDのSが表す原則は？', o: ['単一責任の原則', '安全性の原則', '拡張性の原則', '簡潔性の原則'], a: 0 },
    { q: 'DRY原則の意味は？', o: ['同じことを繰り返すな', '早く乾かせ', 'ドキュメントを読め', 'テストを書け'], a: 0 },
    { q: 'O(n log n)の代表的ソートは？', o: ['マージソート', 'バブルソート', '選択ソート', '挿入ソート'], a: 0 },
    { q: 'スタック(Stack)のアクセス方式は？', o: ['LIFO', 'FIFO', 'ランダムアクセス', '優先度順'], a: 0 },
    { q: 'KISS原則の意味は？', o: ['シンプルに保て', '素早くイテレーション', '常にテスト', 'ペアプロせよ'], a: 0 },
    { q: 'ハッシュテーブルの平均探索計算量は？', o: ['O(1)', 'O(n)', 'O(log n)', 'O(n²)'], a: 0 },
    { q: '二分探索の前提条件は？', o: ['ソート済み', '重複なし', '数値のみ', '固定長'], a: 0 },
    { q: '関数型プログラミングで重視される概念は？', o: ['副作用のない純粋関数', 'クラスの継承', 'グローバル変数活用', 'ポインタ操作'], a: 0 },
    { q: 'Singletonパターンの特徴は？', o: ['インスタンスを1つだけ生成', '複数IFを統合', 'オブジェクト複製', '処理を並列化'], a: 0 },
    { q: 'SOLIDのOが表す原則は？', o: ['開放閉鎖の原則', '最適化の原則', 'OOP原則', '順序の原則'], a: 0 },
    { q: '再帰関数に必要不可欠な要素は？', o: ['基底条件', 'グローバル変数', 'マルチスレッド', '例外処理'], a: 0 },
    { q: '連結リストの先頭挿入の計算量は？', o: ['O(1)', 'O(n)', 'O(log n)', 'O(n²)'], a: 0 },
    { q: 'キュー(Queue)のアクセス方式は？', o: ['FIFO', 'LIFO', 'ランダムアクセス', '優先度順'], a: 0 },
    { q: 'ポリモーフィズムの主な利点は？', o: ['同じIFで異なる振る舞い', 'メモリ削減', 'コンパイル短縮', 'DB最適化'], a: 0 },
    { q: 'バブルソートの最悪計算量は？', o: ['O(n²)', 'O(n)', 'O(n log n)', 'O(1)'], a: 0 },
    { q: 'Observerパターンの用途は？', o: ['状態変化を複数に通知', 'データソート', '認証処理', 'DB接続'], a: 0 },
    { q: 'ガベージコレクションの役割は？', o: ['不要メモリの自動解放', 'コード最適化', 'テスト実行', 'ログ出力'], a: 0 },
    { q: '木構造のBFSが使うデータ構造は？', o: ['キュー', 'スタック', 'ハッシュマップ', '配列'], a: 0 },
    { q: 'クロージャとは？', o: ['外部変数を参照する関数', 'クラスの一種', 'ループ構文', 'エラーハンドリング'], a: 0 },
    { q: '抽象クラスとIFの違いは？', o: ['抽象クラスは実装を持てる', '違いはない', 'IFは継承不可', '抽象は多重継承可'], a: 0 },
  ],
  test1: [
    { q: 'ブラックボックステストの特徴は？', o: ['内部構造を考慮せず入出力で検証', 'ソースコードを直接確認', '開発者のみ実施', '自動化不可'], a: 0 },
    { q: '境界値分析で重点的にテストする値は？', o: ['有効範囲の境界付近', 'ランダムな値', '中央値', '最頻値'], a: 0 },
    { q: '単体テストが検証する粒度は？', o: ['関数やメソッド単位', 'システム全体', 'ユーザーシナリオ', 'ネットワーク通信'], a: 0 },
    { q: 'テストカバレッジ100%が保証するものは？', o: ['全コードパスが実行されたこと', 'バグがゼロ', '全要件を満たす', 'テストが完璧'], a: 0 },
    { q: '結合テストの主な目的は？', o: ['モジュール間の連携を検証', 'UIデザイン確認', 'パフォーマンス計測', 'セキュリティ検証'], a: 0 },
    { q: 'TDDの基本サイクルは？', o: ['Red → Green → Refactor', 'Plan → Code → Test', 'Write → Run → Fix', 'Design → Build → Deploy'], a: 0 },
    { q: 'ホワイトボックステストの特徴は？', o: ['内部構造を理解した上で検証', 'ユーザー視点のみ', 'ランダム入力', '本番環境のみ'], a: 0 },
    { q: '同値分割法の考え方は？', o: ['同結果の入力をグループ化', '全入力を個別にテスト', '最悪ケースのみ', '出力のみ確認'], a: 0 },
    { q: 'スモークテストの目的は？', o: ['基本機能が動作するか素早く確認', '負荷耐性確認', 'セキュリティホール発見', '全機能網羅確認'], a: 0 },
    { q: 'モックオブジェクトの主な用途は？', o: ['外部依存を模倣しテスト独立', '本番データ使用', 'テスト高速化', 'UI描画'], a: 0 },
    { q: 'テストフィクスチャとは？', o: ['テスト実行に必要な前提条件や初期データ', '自動化ツール', '結果レポート', 'テンプレート'], a: 0 },
    { q: 'ミューテーションテストの目的は？', o: ['テストの品質を評価', 'コードを変異させる', '負荷テスト', 'UIテスト'], a: 0 },
    { q: 'テストダブルに含まれないものは？', o: ['コンパイラ', 'スタブ', 'モック', 'スパイ'], a: 0 },
    { q: '探索的テストの特徴は？', o: ['スクリプトなしで同時に学習・テスト', '自動テストの一種', '負荷テスト', '回帰テスト'], a: 0 },
    { q: 'ペアワイズテストの目的は？', o: ['パラメータ組み合わせを効率的にテスト', '2人で行うテスト', 'ペアプロ検証', '2回テスト'], a: 0 },
  ],
  refinement: [
    { q: '技術的負債とは？', o: ['短期的解決策で将来発生する追加コスト', '金銭的借入', '未払いライセンス料', 'サーバー老朽化'], a: 0 },
    { q: 'リファクタリングの定義は？', o: ['振る舞いを変えず内部構造を改善', '新機能追加', 'バグ修正', 'パフォーマンス最適化'], a: 0 },
    { q: 'コード可読性を高める最も基本的な方法は？', o: ['適切な命名', 'コメントを大量に', '1行にまとめる', '変数を減らす'], a: 0 },
    { q: 'コードスメルとは？', o: ['深い問題を示唆する表面的兆候', 'コンパイルエラー', '実行時エラー', 'セキュリティ脆弱性'], a: 0 },
    { q: 'リファクタリングと機能追加の違いは？', o: ['振る舞いを変えない', '常に高速化', '機能追加は構造改善', '違いはない'], a: 0 },
    { q: '技術的負債蓄積で最も影響を受けるのは？', o: ['変更コストと時間', 'サーバー物理寿命', 'チーム人数', '言語選択'], a: 0 },
    { q: 'ボーイスカウトルールとは？', o: ['コードを見つけた時より綺麗にして去る', '最小限の変更', 'ドキュメント必須', 'ペアプロ義務化'], a: 0 },
    { q: '循環的複雑度が高いコードの特徴は？', o: ['分岐やループが多く理解困難', '行数が多い', '変数が多い', '関数が少ない'], a: 0 },
    { q: 'マジックナンバーとは？', o: ['意味不明な数値リテラル', '乱数シード値', '暗号化キー', 'バージョン番号'], a: 0 },
    { q: 'デッドコードとは？', o: ['実行されないコード', '低速コード', 'テストなしコード', '古い言語のコード'], a: 0 },
    { q: '凝集度が高いモジュールの特徴は？', o: ['関連機能がまとまっている', '多くの外部依存', '行数が少ない', 'グローバル変数使用'], a: 0 },
    { q: 'ロングメソッドが問題な理由は？', o: ['理解・テスト・保守が困難', '実行速度低下', 'メモリ不足', '命名困難'], a: 0 },
    { q: '神クラスの問題点は？', o: ['責務集中で変更影響大', 'パフォーマンス良すぎ', 'テスト簡単すぎ', '依存少なすぎ'], a: 0 },
    { q: 'Lintツールの主な目的は？', o: ['コードスタイルや問題を自動検出', 'コード自動修正', 'テスト実行', 'ビルド最適化'], a: 0 },
    { q: '技術的負債の返済タイミングは？', o: ['計画的に少しずつが理想', '一切返済しない', 'PJ終了時', 'お金が貯まったら'], a: 0 },
  ],
  impl2: [
    { q: '既存コード修正時に最も重要な考慮は？', o: ['影響範囲の把握', '実装速度', 'コメント追加', '変数名統一'], a: 0 },
    { q: '副作用(Side Effect)とは？', o: ['関数がスコープ外の状態を変更', 'バグのこと', 'パフォーマンス低下', 'メモリリーク'], a: 0 },
    { q: '密結合のデメリットは？', o: ['一箇所の変更が広範囲に影響', '実行速度が遅い', 'メモリ使用量大', 'コード行数増加'], a: 0 },
    { q: 'DI(依存性注入)の目的は？', o: ['結合度を下げる', '実行速度向上', 'メモリ節約', 'セキュリティ強化'], a: 0 },
    { q: '変更耐性の高いコードの特徴は？', o: ['責務が適切に分離', '行数が少ない', 'コメントが多い', '最新言語で記述'], a: 0 },
    { q: 'デグレード(デグレ)とは？', o: ['修正により既存機能が壊れること', 'パフォーマンス向上', 'バージョンアップ', 'コード圧縮'], a: 0 },
    { q: 'フィーチャーフラグの目的は？', o: ['機能ON/OFFをデプロイと分離', 'コンパイル高速化', 'セキュリティ強化', 'ログ出力'], a: 0 },
    { q: 'SOLIDのDが表す原則は？', o: ['依存性逆転の原則', '防御的プログラミング', '分散処理原則', 'データ駆動原則'], a: 0 },
    { q: 'ISPの意味は？', o: ['不要メソッドへの依存を強制しない', 'UI分離', 'ネットワーク分離', 'DB分離'], a: 0 },
    { q: '後方互換性を維持する理由は？', o: ['既存利用者に影響を与えない', 'コードを短く', '新機能追加', 'テスト省略'], a: 0 },
    { q: 'ストラングラーフィグパターンとは？', o: ['旧システムを段階的に新に置換', '一括刷新', 'テスト環境分離', 'データ移行'], a: 0 },
    { q: 'セマンティックバージョニングでメジャー版を上げる条件は？', o: ['後方互換性のない変更', 'バグ修正', '新機能追加', 'ドキュメント更新'], a: 0 },
    { q: 'アダプターパターンの目的は？', o: ['互換性のないIFを変換し接続', 'データ圧縮', 'UI統一', 'ログ出力'], a: 0 },
    { q: 'CIで最も重要な原則は？', o: ['頻繁にメインブランチに統合', '月1回リリース', '手動テスト', '大きな変更をまとめる'], a: 0 },
    { q: 'リスコフの置換原則(LSP)とは？', o: ['サブクラスは親と置換可能であるべき', 'リスク管理', 'リスト置換', 'ログ置換'], a: 0 },
  ],
  test2: [
    { q: '回帰テストの目的は？', o: ['変更後に既存機能が壊れてないか確認', '新機能のみ確認', 'パフォーマンス計測', 'セキュリティ検証'], a: 0 },
    { q: 'リリース前に最も重視される品質観点は？', o: ['クリティカルな不具合がないこと', 'コードが美しい', '全テスト自動化', 'ドキュメント完全'], a: 0 },
    { q: 'E2Eテストが検証する範囲は？', o: ['システム全体のユーザーシナリオ', '関数単体', 'モジュール間接続', 'DBのみ'], a: 0 },
    { q: 'リリース判定で確認すべき事項は？', o: ['既知不具合の影響度と対応方針', 'コード行数', '開発者人数', '会議回数'], a: 0 },
    { q: 'カナリアリリースとは？', o: ['一部ユーザーに先行リリース', '深夜リリース', '全ユーザー一斉', 'テスト環境のみ'], a: 0 },
    { q: '受け入れテストの主な実施者は？', o: ['POやステークホルダー', '開発者のみ', 'QAのみ', 'AIツール'], a: 0 },
    { q: 'テストピラミッドで最も数が多いべきテストは？', o: ['単体テスト', 'E2Eテスト', '結合テスト', '手動テスト'], a: 0 },
    { q: 'フレイキーテストとは？', o: ['同条件で結果が変わる不安定なテスト', '高速テスト', '古いテスト', '手動テスト'], a: 0 },
    { q: 'ブルーグリーンデプロイメントの特徴は？', o: ['2環境切替でダウンタイムなし', '環境を青く表示', '環境を緑に統一', '1環境で段階更新'], a: 0 },
    { q: '非機能テストに含まれるものは？', o: ['性能・負荷テスト', '単体テスト', '結合テスト', '受け入れテスト'], a: 0 },
    { q: 'A/Bテストの目的は？', o: ['2つのバリエーションの効果を比較', 'ABの順序テスト', 'ABCの分類', '2回テスト'], a: 0 },
    { q: 'テスト自動化で最も重要な考慮点は？', o: ['メンテナンスコスト', '実行速度のみ', 'テスト数のみ', 'ツール価格'], a: 0 },
    { q: 'ダークローンチとは？', o: ['ユーザーに見せず本番で機能を稼働', '夜間リリース', '秘密リリース', 'テスト環境リリース'], a: 0 },
    { q: 'SLIとは？', o: ['サービス品質の定量的指標', 'セキュリティ指標', 'コスト指標', '開発速度指標'], a: 0 },
    { q: 'ロールバック戦略が重要な理由は？', o: ['リリース失敗時に迅速復旧', 'テスト省略', '開発速度向上', 'コスト削減'], a: 0 },
  ],
  review: [
    { q: 'スプリントレビューの主な目的は？', o: ['成果物を検査しFBを得る', 'チームの反省', '次の計画を立てる', '技術的負債整理'], a: 0 },
    { q: 'スプリントレビューに参加すべき人は？', o: ['チームとステークホルダー', '開発者のみ', 'マネージャーのみ', '顧客のみ'], a: 0 },
    { q: 'スプリントレビューで確認されるのは？', o: ['完了した成果物', '個人パフォーマンス', 'コードの美しさ', '残業時間'], a: 0 },
    { q: '完成の定義(DoD)の目的は？', o: ['品質基準を明確にする', '締め切り決定', '担当者割当', '予算管理'], a: 0 },
    { q: 'インクリメントとは？', o: ['完成した動作する成果物', '未完了タスク', 'バックログ項目', 'テスト結果'], a: 0 },
    { q: 'フィードバックの扱いは？', o: ['バックログへの反映を検討', '即座に全て実装', '次SPで必ず対応', '口頭のみ共有'], a: 0 },
    { q: 'レビューとレトロの違いは？', o: ['レビューは成果物、レトロはプロセス', '違いはない', 'レビューは非公開', 'レビューは任意'], a: 0 },
    { q: 'MVPの考え方は？', o: ['最小限の機能で価値を検証', '全機能後リリース', '最低品質で出す', 'プロトタイプ不要'], a: 0 },
    { q: 'バーンダウンチャートが示すものは？', o: ['残作業量の推移', '売上の推移', 'バグ数の推移', 'チーム人数推移'], a: 0 },
    { q: '透明性がスクラムで重視される理由は？', o: ['正確な検査と適応のため', '報告書削減', '会議増加', '管理者が監視'], a: 0 },
    { q: 'NPSとは？', o: ['顧客ロイヤルティの指標', '開発速度指標', 'コード品質指標', 'テスト網羅性指標'], a: 0 },
    { q: 'OKRの「KR」は何の略？', o: ['Key Results', 'Key Requirements', 'Knowledge Review', 'Known Risks'], a: 0 },
    { q: 'レトロスペクティブで議論すべきことは？', o: ['プロセスの改善点', '個人評価', '次の機能仕様', '予算'], a: 0 },
    { q: 'KPTのKは何を表す？', o: ['Keep', 'Kill', 'Know', 'Key'], a: 0 },
    { q: 'POの「No」が重要な理由は？', o: ['スコープ拡大を防ぎ価値に集中', 'モチベーション低下', 'コスト削減', 'テスト省略'], a: 0 },
  ],
  emergency: [
    { q: '本番障害発生時にまず行うべきことは？', o: ['影響範囲の確認と切り分け', '原因の特定', '修正コード作成', '報告書作成'], a: 0 },
    { q: 'ロールバックとは？', o: ['直前の安定版に戻すこと', '新バージョンリリース', 'サーバー再起動', 'ログ削除'], a: 0 },
    { q: 'エスカレーションの意味は？', o: ['上位者に報告・判断を仰ぐ', '問題を無視', '自分だけで解決', '顧客に謝罪'], a: 0 },
    { q: 'ポストモーテムの目的は？', o: ['根本原因分析と再発防止', '責任者処罰', '記録のみ', '説明資料作成'], a: 0 },
    { q: 'SLAとは？', o: ['Service Level Agreement', 'System Level Architecture', 'Software License Agreement', 'Standard Log Analysis'], a: 0 },
    { q: 'MTTRが示すものは？', o: ['平均復旧時間', '平均故障間隔', '最大応答時間', '最小稼働率'], a: 0 },
    { q: '障害時コミュニケーションで最も重要なのは？', o: ['関係者への迅速な状況共有', '詳細な技術報告', '原因の完全特定', '修正の完了'], a: 0 },
    { q: 'MTBFが示すものは？', o: ['平均故障間隔', '平均復旧時間', '最大稼働時間', '最小応答時間'], a: 0 },
    { q: 'RCAで用いられる手法は？', o: ['なぜなぜ分析', 'SWOT分析', 'ABC分析', '回帰分析'], a: 0 },
    { q: 'カオスエンジニアリングの目的は？', o: ['意図的障害で耐障害性検証', '混乱を招く', 'テスト省略', '障害隠蔽'], a: 0 },
    { q: 'オンコール体制の目的は？', o: ['24時間障害に即応', '常に開発', 'テスト実行', 'ドキュメント作成'], a: 0 },
    { q: '障害レベル分類(Severity)の目的は？', o: ['影響度に応じた対応優先度決定', '障害を隠す', '報告書書式', 'コスト計算'], a: 0 },
    { q: 'ウォールームとは？', o: ['重大障害時の緊急対応室', 'サーバールーム', '休憩室', '会議室の別名'], a: 0 },
    { q: 'SLOとは？', o: ['サービス品質の目標値', 'セキュリティ目標', '開発目標', 'テスト目標'], a: 0 },
    { q: 'エラーバジェットの考え方は？', o: ['許容ダウンタイムの予算設定', 'エラー費用', 'バグ修正予算', 'テスト予算'], a: 0 },
  ],
};
